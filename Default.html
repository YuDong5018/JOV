<!DOCTYPE html>
<head>
    <meta charset="utf-8">
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <title>MapboxGL & D3.js</title>

    <style>
        .mapboxgl-ctrl-bottom-left div{
            display:none !important;
        }
        .mapboxgl-ctrl-attrib-inner {
            display: none;
        }
        html, body, #wrapper {
            width: 100%;
            height: 100%;
            padding: 0px;
            margin: 0px;
            overflow: hidden;
        }

        .node {
            cursor: pointer;
        }

        #map {
            position:relative;
            width: 100%;
            height: 100%;
            margin: auto auto;
        }
        svg {
            /*position: absolute;*/
            width: 100%;
            height: 100%;
        }
        .hidden {
            display: none;
        }

        .brush .extent {
            stroke: #000;
            stroke-width: 1.5px;
            fill: #000;
            fill-opacity: 0.3;
        }

        .voronoi {
            fill: steelblue;
            fill-opacity: 0.4;
            stroke: steelblue;
            stroke-opacity: 0.5;
        }

        .voronoi.selected {
            fill: red;
            fill-opacity: 0.4;
            stroke: darkred;
            stroke-opacity: 0.5;
        }

        .dots.selected {
            fill: red;
            stroke: darkred;
            stroke-width: 1;
        }
        #features {
            position: absolute;
            top: 0;
            right: 2.5%;
            bottom: 0;
            width: 33%;
            height: 100%;
            overflow: auto;
            background: rgba(255, 255, 255, 0);

        }

        #controlpanel{
            position: absolute;
            float: left;
            left: 0;
            bottom: 0;
            width: 17%;
            overflow: auto;
            height: 150px;
            background: rgba(255, 255, 255, 0.8);
            margin: 1em 0.5em;
        }

        #timeline{
            position: absolute;
            float: left;
            left: 17.7%;;
            bottom: 0;
            width: 45.7%;
            height: 150px;
            overflow: auto;
            background: rgba(255, 255, 255, 0.8);
            margin: 1em 0.5em;
        }

        #treestructure{

            float: left;
            left: 0;
            bottom: 0;
            width: 100%;
            height: 40.5%;
            overflow: auto;
            background: rgba(255, 255, 255, 0.8);
            margin: 0.5em 0;
        }
        .outerRectShow{
            display: flex;
            float: left;
            left: 0;
            bottom: 0;
            width: 100%;
            height: 56%;
            overflow: auto;
            background: rgba(255, 255, 255, 0.8);
            margin: 0.5em 0;
        }
        #appendSVG{
            width: 99%;
            height: 100%;

        }

        .divlegend{
            position: absolute;
            text-align: left;
            width: 185px;
            font-size: 14px;
            background: #444444;
            padding: 4px;
            /*padding: 2vw;*/
            /*font: 1vw sans-serif;*/
            border: 0px;
            border-radius: 5px;
            color:white;
            /*字体颜色*/
            box-shadow: -3px 3px 15px #888888;
            opacity:0.8;
            display: none;
            overflow: hidden;

        }
        .content {

            height: 96%;
            width: 100%;
            float: left;
        }
        .legendexample {
            /*background-color: #fff;*/
            border-radius: 3px;
            /*bottom: 20px;*/
            /*box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);*/
            /*font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;*/
            /*padding: 5px;*/
            /*position: absolute;*/
            /*right: 10px;*/
            width: 100%;
        }
        .legendexample div span {
            border-radius: 50%;
            display: inline-block;
            height: 10px;
            margin-right: 5px;
            width: 10px;
        }
        /*.divtitle {position:relative;margin:2px;}*/
        /*.divtitle h2{font-size:14px; color: #1b1e21; height:15px;line-height:18px;border-bottom:0px solid #262629;}*/
        /*.divtitle div{position:absolute;height:15px;top:2px;right:0;}*/


    </style>

    <script src="../../Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4f57f85c8ae56a0c2e64f5d53a08877d/Message/MessageTemp/9e20f478899dc29eb19741386f9343c8/File/matrix.js"></script>

    <script src='./JS/bootstrap.min.js'></script>
    <link rel="stylesheet" href="./CSS/bootstrap.min.css" type="text/css">
    <script src='./JS/d3.v4.min.js'></script>
    <script src='./JS/d3.v5.min.js'></script>
    <!--<script src='https://api.tiles.mapbox.com/mapbox-gl-js/v0.52.0/mapbox-gl.js'></script>-->
    <script src='./JS/d3.v3.min.js'></script>
    <!--<script src="https://d3js.org/topojson.v1.min.js"></script>-->
    <script src="./JS/supercluster.js"></script>
    <script src="./JS/polybrush.js"></script>
    <script src="./JS/mapbox-gl-draw.js"></script>
    <link rel="stylesheet" href="./CSS/mapbox-gl-draw.css" type="text/css">
    <script src="./JS/turf.min.js"></script>
    <script src="./JS/jquery.min.js"></script>
    <script src="./JS//jquery-ui.min.js"></script>
    <script src="./JS//jquery.csv.min.js"></script>
    <link href="./CSS/mapbox-gl.css" rel="stylesheet">
    <script src="./JS/mapbox-gl.js"></script>
    <script src='./JS/mapbox.js'></script>

    <!--<script type="text/javascript" src="./JS/windowstyle.js"></script>-->

    <link href='./CSS/mapbox.css' rel='stylesheet' />
    <link href='./CSS/timeline.css' rel='stylesheet' />
    <!--    <link href='./CSS/windowstyle.css' rel='stylesheet' />-->
    <link href='./CSS/style.css' rel='stylesheet' />
    <link href='./CSS/demo.css' rel='stylesheet' />
    <link href='./CSS/normalize.css' rel='stylesheet' />

    <link type="text/css" rel="stylesheet" href="./CSS/force.css"/>
</head>

<body>
<div id="wrapper">
    <!--    <button onclick="myFunction()">Click me</button>-->
    <div id="map"></div>
    <div id = "controlpanel">

        <div class="input-group" >
            <!--            <div class="divtitle" style="height: 10%;width: 100%;" >-->
            <!--                <h2>Control Panel</h2>-->
            <!--            </div>-->
            <div class = "content" id="basicinfo" style="height: 30%;width: 100%;" >
                <div class = "content" id="Datasource" style="height: 10%;width: 100%; padding-left: 5px; padding-right: 5px; padding-top: 5px;" >
                    <label>DataSource:</label>
                    <input type="text" id="Datasourcetimeline" name="username" value= "NSW LGAs Covid-19 2020/01 - 2022/01" readonly unselectable="on" style="width: 245px">

                </div>
                <div class = "content" id="Otherinfo" style="height: 10%;width: 100%; padding-left: 5px; padding-right: 5px; padding-top: 5px;" >
                    <div id="ClusterRadius" style="width: 60%; float: left">
                        <label>ClusterRadius:</label>
                        <input type="text" id="Inputclustersource" name="username" value= "50" readonly unselectable="on" style="width: 40px;text-align:center">
                        <label>(Tile Width)</label>
                    </div>

                    <div id="Timespan" style="width: 40%; float: left">
                        <label>Timespan:</label>
                        <input type="text" id="Inputtimespan" name="username" value= "Monthly" readonly unselectable="on" style="width: 65px;text-align:center">
                    </div>
                </div>
            </div>

            <div class = "content" id="selectedtime" style="height: 10%;width: 100%; padding-left: 5px; padding-right: 5px; padding-top: 5px;" >
                <label>Selected Timeline:</label>
                <input type="text" id="SelectedTimeline" name="username" value= "2020/01 - 2022-01, total 25 months" readonly unselectable="on" style="width: 213px">
            </div>
            <div class = "content" id="tooltips" style="height: 40%;width: 100%; padding-left: 5px; padding-right: 5px; padding-top: 5px;" >
                <div class = "content" id="tooltip" style="height: 100%;width: 80%;" >
                    <label>Color Tooltips:</label><br>
                    <div id="LegendExample" class="legendexample">
                        <div style="width: 30%; float: left; "><span style="background-color: #223971"></span>Single</div>
                        <div style="width: 30%; float: left; "><span style="background-color: #3E9A34"></span>Clustered</div>
                        <div style="width: 40%; float: left; "><span style="background-color: #F4801F"></span>Selected (LGAs)</div> <br>
                        <div style="width: 60%; float: left; "><span style="background-color: #D0637C"></span>Government Intervention</div>
                        <div style="width: 40%; float: left; "><span style="background-color: #EABEC3"></span>Restriction</div><br>
                        <div style="width: 60%; float: left; "><span style="background-color: rgba(86,71,121,0.8)"></span>Selcted timeline</div>
                        <div style="width: 40%; float: left; "><span style="background-color: #CB2026"></span>Cases</div>
                    </div>

                </div>
                <div class = "content" id="buttons" style="height: 100%;width: 20%; padding-left: 2px; padding-right: 2px; padding-top: 15px;" >

                    <div class="input-group-append" style="padding-left: 5px; padding-right: 5px; padding-top: 10px;" >
                        <button class="btn btn-outline-dark btn-sm" type="button" onclick="TimelineChangeButtonClick()">Filter</button>
                    </div>
                </div>


            </div>

        </div>

    </div>
    <div id = "timeline">
        <div id="appendBrushSVG" class="timelinechart" data-role="timelinechart" style = "padding-top: 5px; padding-bottom: 5px; padding-left: 2px; padding-right: 2px;">
        </div>
    </div>
    <div id="features">

        <div class="outerRectShow" style="padding: 10px">
            <div id="appendSVG">

            </div>
        </div>

        <div id="treestructure">

        </div>

    </div>
</div>

<script type="text/javascript" src="./JS/force.js"></script>
<script type="text/javascript" src="./JS/matrix.js?v=1"></script>
<script type="text/javascript" src="./JS/timeline.js"></script>

<script>

    //COLOR PANEL
    var ColorGrey = ['#C0C0C0'];
    var Flowercolorpannel = ['#CB2026','#1f78b4','#b2df8a','#33a02c','#fb9a99','#a6cee3','#fdbf6f','#ff7f00','#cab2d6','#6a3d9a','#ffff99'];

    //var mapcirclecolor = ["#0F9D58","#4285F4","#F4B400"]; //google color
    var mapcirclecolor = ["#3E9A34","#223971","#F4801F"]; //aldi color

    var LGAcenter = {
        type: 'FeatureCollection',
        features: []
    };
    var LGAcenterforD3 = {
        type: 'FeatureCollection',
        features: []
    };
    var LGAcenterofMonth= {
        type: 'FeatureCollection',
        features: []
    };

    //var tempclustersinfo = [];
    // var wasLoaded = false;
    var mapboxDynamicCluster = [];
    var mapboxtempPolygonPoints = [];
    var mapsaveparameters = [];
    var mapsavegroups = [];
    var mapsavegroupsforallcaseslist = [];
    var finalcenterpoint = []; //for global storage center point
    var finalcenterpointallcaseslist = []; //for global storage center point all caseslist
    var templgacodestore = [];
    var clusterdiff = [];
    var unclusterdiff = [];
    var savetotaldata = [];
    var storeid = 0;
    var tempstringLGAcenterofMonth;
    var tempLGAcenterofMonth = [];
    var tempLGAcenterofMonthbytimeline = [];
    var tempclustersinfo = [];
    var tempstorelgacode = [];
    var updatefeatures = {};
    var tempfinalcenterpointcopy = [];
    var temptimearr = new Array(2).fill(0);
    window.storagearr = [];
    window.storageinfo = [];
    window.clickcount = 1;

    var myEvent = new Event('dispatchSaveTotalData');

    var switchflag = 0;

    //var loadflag = 0;
    var margin = {top: 30, right: 18, bottom: 10, left: 10};

    var nswBounds = [
        [140, -38],
        [157, -27]
    ];

    mapboxgl.accessToken = 'pk.eyJ1IjoibWFnZTUwMTgiLCJhIjoiY2psd3cwemxuMTlyYzNwb2d4cXhyNGx0ZSJ9.VkkG4riV7oxGcAnStBiHJA'
    var map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mage5018/ckbumhoti0mes1iqmcl4m1qo7',
        zoom: 5.8,
        center: [150.91, -33.30],
        pitchWithRotate: false,
        dragRotate: true,
        //maxBounds: nswBounds,
        //attributionControl: true
    });

    var maxnumber;
    var svg;
    var brush;
    var tickflag = 0;
    var areaflag = 0;
    var clusterarr = [];
    //var otherclusterarr = [];
    var otherclusterarr = [];
    var clusterstring = "";
    var centrepoint = [];
    var centrepointallcaseslist = [];
    var group_cluster, group_uncluster, group_select;
    window.timelineflag = 0;


    // $.getJSON('./Data/11nsw-lga-boundaries.geojson',function(geojson) {
    $.getJSON('./Data/nsw_lga_polygon_V5.geojson',function(geojson) {


        $.getJSON('./Data/New_Month_Result.json',function(monthjson) {
            var storearr = [];
            console.log(monthjson)

            for (var a = 0; a < geojson.features.length; a++) {
                var temparr = [];
                for (var b = 0; b < monthjson.RECORDS.length; b ++)
                {

                    if (geojson.features[a].properties.lgacode == monthjson.RECORDS[b].lgacode)
                    {
                        var tempsplitdate = monthjson.RECORDS[b].Date.split("/");
                        maxnumber = 25; //共计月份数量，25
                        // if (monthjson.RECORDS[b].cases != 0)
                        // {
                        //     console.log(monthjson.RECORDS[b].Date + ", " + monthjson.RECORDS[b].lgacode + " has " + monthjson.RECORDS[b].cases);
                        // }
                        if (tempsplitdate[1] === '2020'){
                            temparr.push({
                                "Month": Number(tempsplitdate[0]),
                                "Year": tempsplitdate[1],
                                "lgacode": monthjson.RECORDS[b].lgacode,
                                "nsw_lga_3": monthjson.RECORDS[b].nsw_lga_3,
                                "cases": monthjson.RECORDS[b].cases,
                                "start": 360 / maxnumber * (Number(tempsplitdate[0]) - 1),
                                "end": 360 / maxnumber * Number(tempsplitdate[0])
                            });
                        }
                        else if (tempsplitdate[1] === '2021'){
                            temparr.push({
                                "Month": Number(tempsplitdate[0]) + 12,
                                "Year": tempsplitdate[1],
                                "lgacode": monthjson.RECORDS[b].lgacode,
                                "nsw_lga_3": monthjson.RECORDS[b].nsw_lga_3,
                                "cases": monthjson.RECORDS[b].cases,
                                "start": 360 / maxnumber * (Number(tempsplitdate[0]) - 1 + 12),
                                "end": 360 / maxnumber * (Number(tempsplitdate[0]) + 12)
                            });
                        }
                        else if (tempsplitdate[1] === '2022'){
                            temparr.push({
                                "Month": Number(tempsplitdate[0]) + 24,
                                "Year": tempsplitdate[1],
                                "lgacode": monthjson.RECORDS[b].lgacode,
                                "nsw_lga_3": monthjson.RECORDS[b].nsw_lga_3,
                                "cases": monthjson.RECORDS[b].cases,
                                "start": 360 / maxnumber * 24,
                                "end": 360 / maxnumber * 25
                            });
                        }

                    }

                }
                //console.log(temparr);

                LGAcenterofMonth.features.push({
                    "type": "Feature",
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": geojson.features[a].geometry.coordinates
                    },

                    "properties": {
                        "geo_point_2d": [geojson.features[a].properties.geo_point_2d[0], geojson.features[a].properties.geo_point_2d[1]],
                        "name": geojson.features[a].properties.nsw_lga_3,
                        //"mag": Math.ceil(Math.random()*10),
                        "lgacode": geojson.features[a].properties.lgacode,
                        "caseslist": temparr
                    }
                });

                LGAcenter.features.push({
                    "type": "Feature",
                    "geometry": {
                        "type": "Point",
                        "coordinates": [geojson.features[a].properties.geo_point_2d[1], geojson.features[a].properties.geo_point_2d[0]]
                        //swap latlng orders
                    },
                    "properties": {
                        "geo_point_2d": [geojson.features[a].properties.geo_point_2d[0], geojson.features[a].properties.geo_point_2d[1]],
                        "name": geojson.features[a].properties.nsw_lga_3,
                        //"mag": Math.ceil(Math.random()*10),
                        "lgacode": geojson.features[a].properties.lgacode,
                        "caseslist": temparr
                    }
                })


            }


            tempstringLGAcenterofMonth = JSON.stringify(LGAcenterofMonth);
            tempLGAcenterofMonth = JSON.parse(tempstringLGAcenterofMonth);
            tempclustersinfo = [];
            tempstorelgacode = [];

            console.log(tempLGAcenterofMonth);


            //map.addControl(new mapboxgl.NavigationControl());
            var draw = new MapboxDraw({
                displayControlsDefault: false,
                // Select which mapbox-gl-draw control buttons to add to the map.
                controls: {
                    polygon: true,
                    trash: true
                },
                // Set mapbox-gl-draw to draw by default.
                // The user does not have to click the polygon control button first.
                //defaultMode: 'draw_polygon'
            });
            map.addControl(draw);

// Original ES6 Class— https://github.com/tobinbradley/mapbox-gl-pitch-toggle-control
// export default class PitchToggle {
            class PitchToggle {
                constructor({ bearing = -20, pitch = 70, minpitchzoom = null }) {
                    this._bearing = bearing;
                    this._pitch = pitch;
                    this._minpitchzoom = minpitchzoom;
                }

                onAdd(map) {
                    this._map = map;
                    let _this = this;

                    this._btn = document.createElement("button");
                    this._btn.className = "mapboxgl-ctrl-icon mapboxgl-ctrl-pitchtoggle-3d";
                    this._btn.type = "button";
                    this._btn["aria-label"] = "Toggle Pitch";
                    this._btn.onclick = function() {
                        if (map.getPitch() === 0) {
                            let options = { pitch: _this._pitch, bearing: _this._bearing };
                            if (_this._minpitchzoom && map.getZoom() > _this._minpitchzoom) {
                                options.zoom = _this._minpitchzoom;
                            }
                            map.easeTo(options);
                            _this._btn.className =
                                "mapboxgl-ctrl-icon mapboxgl-ctrl-pitchtoggle-2d";
                        } else {
                            map.easeTo({ pitch: 0, bearing: 0 });
                            _this._btn.className =
                                "mapboxgl-ctrl-icon mapboxgl-ctrl-pitchtoggle-3d";
                        }
                    };

                    this._container = document.createElement("div");
                    this._container.className = "mapboxgl-ctrl-group mapboxgl-ctrl";
                    this._container.appendChild(this._btn);

                    return this._container;
                }

                onRemove() {
                    this._container.parentNode.removeChild(this._container);
                    this._map = undefined;
                }
            }

            /* Idea from Stack Overflow https://stackoverflow.com/a/51683226  */
            class MapboxGLButtonControl {
                constructor({
                                className = "",
                                title = "",
                                eventHandler = evtHndlr
                            }) {
                    this._className = className;
                    this._title = title;
                    this._eventHandler = eventHandler;
                }

                onAdd(map) {
                    this._btn = document.createElement("button");
                    this._btn.className = "mapboxgl-ctrl-icon" + " " + this._className;
                    this._btn.type = "button";
                    this._btn.title = this._title;
                    this._btn.onclick = this._eventHandler;

                    this._container = document.createElement("div");
                    this._container.className = "mapboxgl-ctrl-group mapboxgl-ctrl";
                    this._container.appendChild(this._btn);

                    return this._container;
                }

                onRemove() {
                    this._container.parentNode.removeChild(this._container);
                    this._map = undefined;
                }
            }

            /* Event Handlers */
            function one(event) {
                alert("Event handler when clicking on \r\n" + event.target.className);
                console.log("event number 1", event);
            }

            function two(event) {
                alert("Event handler when clicking on \r\n" + event.target.className);
                console.log("event number 2", event);
            }
            function cancel(event) {
                alert("Event handler when cancel \r\n" + event.target.className);
                otherclusterarr = [];
                finalcenterpoint = [];
                finalcenterpointallcaseslist = [];
            }

            function save(event) {
                console.log(window.storagearr);
                if (areaflag == 0){
                    alert("Please apply filter function!");
                    return;
                }

                Unique(window.storagearr);


                storeid++;
                tickflag = 1;

                var tempnumber;

                var tempsaveforeach = [];

                console.log("save begins");

                console.log(updatefeatures.features); //筛选时间后的总数据

                // console.log(mapboxDynamicCluster); //all cluster points
                console.log(tempLGAcenterofMonth.features); //all unclustered points
                // console.log(LGAcenterofMonth); // all point data
                console.log(tempclustersinfo); // all cluster details
                console.log(tempfinalcenterpointcopy); // all grouped details，respone after clicking button
                console.log(finalcenterpointallcaseslist); // all grouped details，respone after clicking button
                //console.log([Number(window.realtimetimestart), Number(window.realtimeend)])

                //QueryUpdateMap(tempnumber, tempsaveforeach, QueryUpdateMapCluster, WriteUpdateMap);

                // console.log(savetotaldata);
                // console.log(updatefeatures);

                if (timelineflag == 0){
                    tempnumber = 25;
                }
                else if (timelineflag == 1){
                    //alert([Number(window.realtimeend), Number(window.realtimetimestart)]);
                    tempnumber = Number(window.realtimeend) -  Number(window.realtimetimestart) + 1;
                }

                //此时应该判断多次group操作与cluster有没有重复的点
                Findgroupdata(tempsaveforeach, Findgroupdata1,Findgroupdata2);

                // console.log(finalcenterpoint);
                // console.log(otherclusterarr);
                // console.log(unclusterdiff);
                //
                // console.log(savetotaldata);

                //目前不考虑删除数据了，savetotaldata是全部的存储数据，storeid是存储序号，mappara是地图参数

                areaflag = 0;
                console.log("save ends");
            }



            function switchdiv(event) {
                //alert("Event handler when clicking on \r\n" + event.target.className);
                //console.log("event clear", event);
                if (switchflag == 0){
                    document.getElementById("controlpanel").style.visibility="hidden";//隐藏
                    document.getElementById("timeline").style.visibility="hidden";//隐藏

                    switchflag = 1;
                }
                else{
                    document.getElementById("controlpanel").style.visibility="visible";//显示
                    document.getElementById("timeline").style.visibility="visible";//显示
                    switchflag = 0;
                }



            }

            /* Instantiate new controls with custom event handlers */
            const ctrlPoint = new MapboxGLButtonControl({
                className: "mapbox-gl-draw_point",
                title: "Draw Point",
                eventHandler: one
            });

            const ctrlCorrect = new MapboxGLButtonControl({
                className: "mapbox-gl-draw_symbol_correct",
                title: "Draw Line",
                eventHandler: save
            });
            const ctrlFalse = new MapboxGLButtonControl({
                className: "mapbox-gl-draw_symbol_false",
                title: "Draw Line",
                eventHandler: cancel
            });
            const ctrlFlower = new MapboxGLButtonControl({
                className: "mapbox-gl-draw_symbol_flower",
                title: "Draw Line",
                eventHandler: two
            });
            // const ctrlRadialarea = new MapboxGLButtonControl({
            //     className: "mapbox-gl-draw_symbol_radialarea",
            //     title: "Draw Line",
            //     eventHandler: two
            // });

            const ctrlSwitch = new MapboxGLButtonControl({
                className: "mapbox-gl-draw_symbol_switch",
                title: "Draw Polygon",
                eventHandler: switchdiv
            });

            /* Add Controls to the Map */
            map.addControl(new mapboxgl.NavigationControl(), "top-left");
            map.addControl(new PitchToggle({ minpitchzoom: 11 }), "top-left");
            //map.addControl(ctrlPoint, "bottom-left");
            map.addControl(ctrlCorrect, "bottom-right");

            map.addControl(ctrlFalse, "bottom-right");

            map.addControl(ctrlFlower, "top-right");
            map.addControl(ctrlSwitch, "top-right");
            // map.addControl(ctrlRadialarea, "top-right");



            map.on('load', () => {

                map.on('draw.create', updateArea);
                map.on('draw.delete', updateAreaAfterDelete);
                map.on('draw.update', updateArea);
                // Add a data source containing GeoJSON data.
                map.addSource('lga-polygon', {
                    'type': 'geojson',
                    'data': geojson
                });

                // Add a new layer to visualize the polygon.
                map.addLayer({
                    'id': 'polygon-fill',
                    'type': 'fill',
                    'source': 'lga-polygon', // reference the data source
                    'layout': {},
                    'paint': {
                        'fill-outline-color': '#484896',
                        'fill-color': '#e5f5ff', // blue color fill
                        'fill-opacity': 0.2
                    }
                });
                map.addLayer(
                    {
                        'id': 'polygon-highlighted',
                        'type': 'fill',
                        'source': 'lga-polygon',
                        'paint': {
                            'fill-outline-color': '#484896',
                            'fill-color': '#c6dbef',
                            'fill-opacity': 0.3
                        },
                        'filter': ['in', 'lgacode', '']
                    }
                ); // Place polygon under these labels.

                map.addLayer(
                    {
                        'id': 'polygon-highlighted',
                        'type': 'line',
                        'source': 'lga-polygon',
                        'paint': {
                            'fill-outline-color': '#484896',
                            'fill-color': '#c6dbef',
                            'fill-opacity': 0.3
                        },
                        'filter': ['in', 'lgacode', '']
                    }
                ); //

                map.addLayer({
                    'id': 'states-layer-outline',
                    'type': 'line',
                    'source': 'lga-polygon',
                    'paint': {
                        'line-color': '#000',
                        'line-opacity': 0.1,
                        'line-width': 1
                    }
                });

                map.addSource('lga-center-clustered', {
                    'type': 'geojson',
                    'cluster': true,
                    'clusterRadius': 50,
                    'data': LGAcenter
                });

                map.addSource('lga-center-clustered-copy', {
                    'type': 'geojson',
                    'cluster': true,
                    'clusterRadius': 50,
                    'data': LGAcenter
                });
                map.addLayer({
                    'id': 'lga-center-clustered-copy',
                    //透明的copy涂层
                    'type': 'circle',
                    'source': 'lga-center-clustered',
                    'filter': ['==', 'cluster', true],
                    'paint': {
                        'circle-opacity': 0
                    }
                });
                map.addLayer({
                    'id': 'lga-center-unclustered-copy',
                    //透明的copy涂层
                    'type': 'circle',
                    'source': 'lga-center-clustered',
                    'filter': ['!=', 'cluster', true],
                    'paint': {
                        'circle-opacity': 0
                    }
                });

                map.addLayer({
                    'id': 'lga-center-clustered',
                    'type': 'circle',
                    'source': 'lga-center-clustered',
                    'filter': ['==', 'cluster', true],
                    'paint': {
                        'circle-opacity': 1,
                        'circle-color': mapcirclecolor[0],
                        'circle-radius': 11
                    }
                });
                map.addLayer({
                    'id': 'lga-center-unclustered',
                    'type': 'circle',
                    'source': 'lga-center-clustered',
                    'filter': ['!=', 'cluster', true],
                    'paint': {
                        'circle-opacity': 1,
                        'circle-color': mapcirclecolor[1],
                        'circle-radius': 11
                    }
                });

                var container = map.getCanvasContainer()
                const bb = container.getBoundingClientRect();
                svg = d3v5.select(container)
                    .append("svg")
                    .style("position", "absolute")
                    .style("top", 0)
                    .style("left", 0)
                    .attr("width", bb.width)
                    .attr("height", bb.height)

                // .call(zoom)

                window.divlegend = d3.select("body")
                    .append("div")
                    .attr("class", "divlegend");

                group_cluster = svg.append("g").attr('id', 'group_nodecluster')
                group_uncluster = svg.append("g").attr('id', 'group_nodeuncluster')
                group_select = svg.append("g").attr('id', 'group_nodeselect')


                //FirstRender();
                console.log('A load event occurred.');
                map.once('idle', ()=>{
                    FirstRender(); // Call once to render
                    console.log('An initial render done.');
                })
                // map.on('idle', ()=>{
                //     OtherRender();
                //     console.log('An idle event occurred.');
                // })

                //
                map.on('move', ()=>{
                    Allpointset();
                    console.log('A move event occurred.');
                })

                map.on("moveend", function (e) {
                    if (timelineflag == 0){
                        OtherRender();
                    }
                    else if (timelineflag == 1){
                        OtherRenderbyTimeline();
                    }

                    console.log('A move end event occurred.');
                })

                map.on('mousemove', 'lga-center-clustered', (e) => {
                    //console.log(e.point);
                    // map.getCanvas().style.cursor = 'pointer';
                    var mapboxHighlightPolygonPoints = [];
                    var mousemovefeatures = map.queryRenderedFeatures(e.point, {
                        layers: ['lga-center-clustered']
                    })
                    console.log(mousemovefeatures)
                    QueryHighlightPolygons(mapboxHighlightPolygonPoints, mousemovefeatures[0], Polygonscallback, PolygonscallbackAgain);
                });

                map.on('mousemove', 'lga-center-unclustered', (e) => {
                    //console.log(e.point);
                    // map.getCanvas().style.cursor = 'pointer';
                    var mapboxHighlightPolygonPoints = [];
                    var mousemovefeatures = map.queryRenderedFeatures(e.point, {
                        layers: ['lga-center-unclustered']
                    })
                    console.log(mousemovefeatures)
                    var templgacodes = [];
                    templgacodes.push(mousemovefeatures[0].properties.lgacode);
                    map.setFilter('polygon-highlighted', ['in', 'lgacode', ...templgacodes]);
                    // QueryHighlightPolygons(mapboxHighlightPolygonPoints, mousemovefeatures[0], Polygonscallback, PolygonscallbackAgain);
                });

                map.on('mouseout', 'lga-center-clustered', () => {
                    map.setFilter('polygon-highlighted', ['in', 'lgacode', '']);
                });
                map.on('mouseout', 'lga-center-unclustered', () => {
                    map.setFilter('polygon-highlighted', ['in', 'lgacode', '']);
                });


                //timelinechart timeline图

                //gettimelinedata
                // read csv file and convert to json format
                var temptimelinedata = [];
                var timelinedatabyajax = [];
                $.ajax({
                    type: 'GET',
                    url: "./Data/timelinedata.csv",
                    dataType: 'text',
                    success: function (data) {
                        var jsonData = $.csv.toObjects(data);
                        console.log(jsonData);
                        for (let i = 0; i < jsonData.length; i++){

                            temptimelinedata.push({
                                "label": jsonData[i].name,
                                "isIncluded": true,
                                "times": [{
                                    "text": "",
                                    "starting_time": Date.parse(jsonData[i].datefrom),
                                    "ending_time": Date.parse(jsonData[i].dateto)
                                }],
                                "classification": jsonData[i].category
                            })
                        }

                        drawTimeLineByData("appendBrushSVG", temptimelinedata, styleConfig);
                    }, // end: Ajax success API call
                    error: function (e) {
                        alert('An error occurred while processing API calls');
                        console.log("API call Failed: ", e);
                    },

                });
                //console.log(temptimelinedata);

                // console.log(temptimelinedata);
                // console.log(timelinedata);




                // //matrix chart starts
                // var matrixdata = d3.json("./Data/testmatrix.json", function(error, values) {
                //     playRects(appendIdStr, values, styleControler, cols + 1, rectPadding, mapcirclecolor);
                // });



            });
        })
    });

    //Common function
    function Unique(arr){
        if (!Array.isArray(arr)) {
            console.log('type error!')
            return
        }
        var array = [];
        for (var i = 0; i < arr.length; i++) {
            if (array .indexOf(arr[i]) === -1) {
                array .push(arr[i])
            }
        }
        return array;
    }

    //Common function
    function UniqueStoreageid(arr){
        let temp = {}	//	用于name判断
        let result = [] // 最后的新数组
        arr.map((item, index) => {
            if (!temp[item.Storageid]) {
                result.push(item)
                temp[item.Storageid] = true
            }
        })
        return result;
    }
    //Common function
    function UniqueDetailsLGA(arr){
        const res = new Map();
        return arr.filter((item) => !res.has(item["LGAcode"]) && res.set(item["LGAcode"], 1));
    }

    function deWeightCluster(arr) {
        for (var i = 0; i < arr.length - 1; i++) {
            for (var j = i + 1; j < arr.length; j++) {
                if (arr[i].clusterlgacode == arr[j].clusterlgacode) {
                    arr.splice(j, 1);
                    //因为数组长度减小1，所以直接 j++ 会漏掉一个元素，所以要 j--
                    j--;
                }
            }
        }
        return arr;
    }


    //find differences between  two sets
    function getDifferenceSet(arr1,arr2,typeName){
        return Object.values(arr1.concat(arr2).reduce((acc,cur) => {
            if (acc[cur[typeName]] && acc[cur[typeName]][typeName] === cur[typeName]) {
                delete acc[cur[typeName]];
            }else{
                acc[cur[typeName]] = cur;
            }
            return acc ;
        },{}));
    }

    //find differences between  two sets
    function getDifferenceSetLGAcode(arr1, arr2) {
        arr1 = arr1.map(JSON.stringify);
        arr2 = arr2.map(JSON.stringify);
        return arr1.concat(arr2).filter(function (v, i, arr) {
            return arr.indexOf(v) === arr.lastIndexOf(v);
        }).map(JSON.parse)
    }

    // 获取当前的日期时间 格式“yyyy-MM-dd”
    function getFormatDatetoNormal(date) {
        //var date = new Date();
        var seperator1 = "-";
        var month = date.getMonth() + 1;
        var strDate = date.getDate();
        if (month >= 1 && month <= 9) {
            month = "0" + month;
        }
        if (strDate >= 0 && strDate <= 9) {
            strDate = "0" + strDate;
        }
        var currentdate = date.getFullYear() + seperator1 + month + seperator1 + strDate;

        return currentdate;
    }
    function TimelineChangeButtonClick(){
        console.log("Timeline changed click");
        areaflag = 1;

        var timestart = getFormatDatetoNormal(window.timeSelection[0]);
        var timeend = getFormatDatetoNormal(window.timeSelection[1]);

        //fix time format
        if (timestart == "2020-03-25"){
            timestart = "2020-01-01";
        }

        var startarr = timestart.split("-");
        var endarr = timeend.split("-");
        var tempyear = Number(endarr[0]) - Number(startarr[0]);
        var tempmonth = Number(endarr[1]) - Number(startarr[1]);
        //var tempday = Number(endarr[2]) - Number(startarr[2]);
        var tempstart = Number(startarr[0]) - 2020;

        var timespan = tempyear * 12 + tempmonth + 1;
        var tempstartseq = tempstart * 12 + Number(startarr[1]) - 1;

        var timespanarr = [{
            "timespan": timespan,
            "timestart": startarr[0] + '-' + startarr[1],
            "timeend": endarr[0] + '-' + endarr[1],
            "timestartseq": tempstartseq
        }]

        //show actual time in input box
        document.getElementById("SelectedTimeline").value = startarr[0] + '/' + startarr[1] + " - " + endarr[0] + '-' + endarr[1] + ", total "+ timespan + " months";


        var tempfeatures = [];
        //var timelinedatalist = [];
        var temptimestart;
        var temtimeend;

        for (let i = 0; i < LGAcenter.features.length; i++){


            temptimestart = Number(timespanarr[0].timestartseq);
            temtimeend = Number(timespanarr[0].timestartseq) + Number(timespanarr[0].timespan);

            console.log(temptimestart, temtimeend);
            //
            // console.log(LGAcenter.features[i].properties.caseslist.slice(temptimestart, temtimeend));

            //console.log(LGAcenter.features[i].properties);
            tempfeatures.push({
                "geometry": LGAcenter.features[i].geometry,
                "properties": {
                    //"caseslist": LGAcenter.features[i].properties.caseslist,
                    "caseslist": LGAcenter.features[i].properties.caseslist.slice(temptimestart, temtimeend),
                    "lgacode": LGAcenter.features[i].properties.lgacode,
                    "name": LGAcenter.features[i].properties.name,
                    "geo_point_2d": LGAcenter.features[i].properties.geo_point_2d
                },
                "type": "Feature"

            })

        }


        updatefeatures = {
            "type": "FeatureCollection",
            "features": tempfeatures,
            "timelinelist": [temptimestart, temtimeend]

        }
        console.log(updatefeatures);

        if (window.timelineflag == 0){
            temptimearr[0] = 0;
            temptimearr[1] = 25;
            OtherRender();
        }else{
            //console.log(map.getSource('lga-center-clustered'));
            temptimearr[0] = Number(updatefeatures.timelinelist[0]);
            temptimearr[1] = Number(updatefeatures.timelinelist[1]);
            map.getSource('lga-center-clustered').setData(updatefeatures);
            OtherRenderbyTimeline();
        }


        //console.log(map.getSource('lga-center-clustered'));


    }

    function FirstRender(){
        console.log("do render");
        //for first render to initialize
        tempLGAcenterofMonth = JSON.parse(tempstringLGAcenterofMonth);
        mapboxDynamicCluster = [];

        var clusterSourcetemp = map.queryRenderedFeatures({ layers: ['lga-center-clustered'] });
        Calc(clusterSourcetemp, Drawoutput, Draw, Allpointset);

        var tempsaveforeach = [];
        var tempnumber = 25;
        QueryIntialMap(tempnumber, tempsaveforeach, QueryIntialMapCluster, WriteIntialMap)

        // Draw();
    }

    var pie = d3.layout.pie()
        .sort(null)
        //默认降序排列，除非传入null
        .value(function(d) {
            return d.cases;
        });
    var arc = d3.svg.arc()
        .startAngle(function(d) {
            //console.log(d);
            return d.data.start * 2 * Math.PI/360;
        })
        .endAngle(function(d) { return d.data.end * 2 * Math.PI/360; })
        .innerRadius(10)
        .outerRadius(function (d) {
            if( d.value === 0){
                return 11;

            }
            else{
                //console.log(d.value);
                return 11 + 2 * (1.4 + Math.log(d.value) * 1.2);
                //return 15;
            }
        })
        //外部高低
        .cornerRadius(1);

    function OtherRender(){
        console.log("do other renders");
        //for first render to initialize
        var clusterSourcetemp = map.queryRenderedFeatures({ layers: ['lga-center-clustered'] });
        tempLGAcenterofMonth = JSON.parse(tempstringLGAcenterofMonth);
        mapboxDynamicCluster = [];
        CalcAgain(clusterSourcetemp, Drawoutput,  Drawupdate, Allpointset);
    }

    function OtherRenderbyTimeline(){
        console.log("do other renders by timeline");
        //for first render to initialize
        var clusterSourcetemp = map.queryRenderedFeatures({ layers: ['lga-center-clustered-copy'] });
        tempLGAcenterofMonth = JSON.parse(tempstringLGAcenterofMonth);
        mapboxDynamicCluster = [];
        CalcAgainbytimeline(clusterSourcetemp, Drawoutputbytimeline,  DrawupdatebyTimeline, Allpointset);
    }



    async function Calc(data, callback1,callback2,callback3) {
        //console.log(data);
        console.log("do calc");
        tempclustersinfo = [];
        tempstorelgacode = [];
        //document.getElementById('features').innerHTML = "There are " + data.length + " clustered points, they are: ";

        for (let i = 0; i < data.length; i++) {

            await CalcSub(data[i])

        }
        console.log("after do calc");
        callback1(callback2, callback3);
    }

    async function CalcAgain(data, callback1,callback2,callback3){
        //console.log(data);
        console.log("do calc again");
        tempclustersinfo = [];
        tempstorelgacode = [];
        //document.getElementById('features').innerHTML = "There are " + data.length + " clustered points, they are: ";
        for (let i = 0; i < data.length; i++) {

            await CalcSub(data[i])

        }
        console.log("after do calc");
        callback1(callback2, callback3);
    }

    async function CalcAgainbytimeline(data, callback1,callback2,callback3){
        //console.log(data);
        console.log("do calc again by timeline");
        tempclustersinfo = [];
        tempstorelgacode = [];
        //document.getElementById('features').innerHTML = "There are " + data.length + " clustered points, they are: ";
        for (let i = 0; i < data.length; i++) {

            await CalcSub(data[i])

        }
        console.log("after do calc");
        callback1(callback2, callback3);
    }

    function CalcSub(e){

        //console.log(e);
        return new Promise((resolve,reject)=>{

            // console.log("do calcsub");
            var clusterId = e.properties.cluster_id,
                point_count = e.properties.point_count,
                clusterSource = map.getSource('lga-center-clustered');
            //
            // // Get Next level cluster Children
            // //
            clusterSource.getClusterLeaves(clusterId, point_count, 0, function (err, aFeatures) {
                //console.log(aFeatures);
                // document.getElementById('features').innerHTML += JSON.stringify(
                //     aFeatures,
                //     null,
                //     2
                // ) + ",";

                mapboxDynamicCluster.push(aFeatures);
                //console.log(mapboxDynamicCluster);

                // console.log("after calcsub");
                resolve();
                //callback(e);
            });
            // resolve();

        });
    }

    function Drawoutput(callback2,callback3){

        console.log("draw output")
        //console.log(e);
        // console.log(tempclustersinfo)
        // console.log(tempLGAcenterofMonth)

        tempclustersinfo = [];
        var tempstorelgacode = [];
        //console.log(mapboxDynamicCluster);
        for (var i = 0; i < mapboxDynamicCluster.length; i++ )
        {
            var tempclustername = []; //clusters more than one
            var tempclusterlgacode = []; //clusters more than one
            var count = 1;
            var tempsumx = 0;
            var tempsumy = 0;
            var templgasum = [];
            var tempnumber = mapboxDynamicCluster[i][0].properties.caseslist.length;
            var tempmonth = new Array(tempnumber).fill(0); //coresponding to the maxnumber
            for (var j = 0; j < mapboxDynamicCluster[i].length; j++)
            {
                //console.log(mapboxDynamicCluster[i][j].geometry.coordinates);
                tempclustername.push(mapboxDynamicCluster[i][j].properties.name);
                tempclusterlgacode.push(mapboxDynamicCluster[i][j].properties.lgacode);
                tempsumx += mapboxDynamicCluster[i][j].geometry.coordinates[0];
                tempsumy += mapboxDynamicCluster[i][j].geometry.coordinates[1];
                count ++;
                tempstorelgacode.push(mapboxDynamicCluster[i][j].properties.lgacode);

                for (var k = 0; k < mapboxDynamicCluster[i][j].properties.caseslist.length; k++)
                {
                    if (mapboxDynamicCluster[i][j].properties.caseslist[k]["Month"] === k + 1)
                        tempmonth[k] += mapboxDynamicCluster[i][j].properties.caseslist[k]["cases"];

                    //console.log(mapboxDynamicCluster[i][j].properties.caseslist[k]);

                }
                //console.log(tempmonth);
            }
            for (var l = 0; l < tempmonth.length; l++){
                templgasum.push({
                    "Month": l + 1,
                    "cases": tempmonth[l],
                    "start": 360 / tempmonth.length * l,
                    "end": 360 / tempmonth.length * (l+1)
                });
            }
            tempclustersinfo.push({
                "clusterlgacode" : tempclusterlgacode,
                "clustername" : tempclustername,
                "coordinates" : [tempsumy/(count - 1), tempsumx/(count - 1)],
                "count" : count - 1,
                "caseslist": templgasum
            });
        }

        //console.log(tempstorelgacode);

        //var newnodeinfo = [];
        for (let i = 0; i < tempstorelgacode.length; i ++)
        {
            for (let j = 0; j < tempLGAcenterofMonth.features.length; j++)
            {
                if (tempstorelgacode[i] == tempLGAcenterofMonth.features[j].properties.lgacode)
                {
                    tempLGAcenterofMonth.features.splice(j,1);
                    j--
                }
            }
        }
        // console.log(mapboxDynamicCluster);
        // console.log(tempLGAcenterofMonth);
        // console.log(LGAcenterofMonth);
        //console.log(tempclustersinfo);
        console.log("after drawoutput")
        callback2(callback3);
    }

    function Drawoutputbytimeline(callback2,callback3){

        console.log("draw output by timeline")
        //console.log(e);
        // console.log(tempclustersinfo)
        // console.log(tempLGAcenterofMonth)

        tempclustersinfo = [];
        var tempstorelgacode = [];
        // console.log(tempLGAcenterofMonth.features);
        console.log(mapboxDynamicCluster);
        // console.log(updatefeatures.features);

        for (var i = 0; i < mapboxDynamicCluster.length; i++ )
        {
            var tempclustername = []; //clusters more than one
            var tempclusterlgacode = []; //clusters more than one
            var count = 1;
            var tempsumx = 0;
            var tempsumy = 0;
            var templgasum = [];
            var tempnumber2 = mapboxDynamicCluster[i][0].properties.caseslist.length;
            var tempnumber = Number(window.realtimeend) -  Number( window.realtimetimestart) + 1;
            //console.log(tempnumber2);
            var tempmonth = new Array(tempnumber).fill(0); //coresponding to the maxnumber
            var tempmonth2 = new Array(tempnumber2).fill(0); //coresponding to the maxnumber

            //console.log(tempmonth);
            // console.log(tempmonth2);

            for (var j = 0; j < mapboxDynamicCluster[i].length; j++)
            {
                //console.log(mapboxDynamicCluster[i][j].geometry.coordinates);
                tempclustername.push(mapboxDynamicCluster[i][j].properties.name);
                tempclusterlgacode.push(mapboxDynamicCluster[i][j].properties.lgacode);
                tempsumx += mapboxDynamicCluster[i][j].geometry.coordinates[0];
                tempsumy += mapboxDynamicCluster[i][j].geometry.coordinates[1];
                count ++;
                tempstorelgacode.push(mapboxDynamicCluster[i][j].properties.lgacode);

                for (var k = 0; k < mapboxDynamicCluster[i][j].properties.caseslist.length; k++)
                {
                    // if (mapboxDynamicCluster[i][j].properties.caseslist[k]["Month"] === k + 1)
                    tempmonth[k] += mapboxDynamicCluster[i][j].properties.caseslist[k]["cases"];
                    //console.log(mapboxDynamicCluster[i][j].properties.caseslist[k]);

                }

            }
            // console.log(updatefeatures.timelinelist);
            // console.log(tempmonth);

            for (var l = 0; l < tempmonth.length; l++){
                // for (let q = 0; q < updatefeatures.timelinelist.length; q++){
                //
                // }
                var tempmonthnumber = Number(updatefeatures.timelinelist[0]) + l;

                templgasum.push({
                    "Month": tempmonthnumber,
                    "cases": tempmonth[l],
                    "start": 360 / tempmonth.length * l,
                    "end": 360 / tempmonth.length * (l+1)
                });
                //console.log(templgasum);
            }
            tempclustersinfo.push({
                "clusterlgacode" : tempclusterlgacode,
                "clustername" : tempclustername,
                "coordinates" : [tempsumy/(count - 1), tempsumx/(count - 1)],
                "count" : count - 1,
                "caseslist": templgasum
            });
        }

        //console.log(tempstorelgacode);
        console.log(tempclustersinfo);
        console.log(tempLGAcenterofMonth);

        for (let i = 0; i < tempstorelgacode.length; i ++)
        {
            for (let j = 0; j < tempLGAcenterofMonth.features.length; j++)
            {
                //console.log(tempLGAcenterofMonth.features[j].properties);

                if (tempstorelgacode[i] == tempLGAcenterofMonth.features[j].properties.lgacode)
                {

                    tempLGAcenterofMonth.features.splice(j,1);
                    j--
                }

            }
        }


        for (let i = 0; i < tempLGAcenterofMonth.features.length; i++){
            tempLGAcenterofMonth.features[i].properties.caseslist = tempLGAcenterofMonth.features[i].properties.caseslist.slice(updatefeatures.timelinelist[0], updatefeatures.timelinelist[1]);
        }

        for (let i = 0; i < tempLGAcenterofMonth.features.length; i++){
            var newtempcaseslist = [];
            var newtempproperties = [];
            for (let j = 0; j < tempLGAcenterofMonth.features[i].properties.caseslist.length; j++){
                newtempcaseslist.push({
                    "Month": tempLGAcenterofMonth.features[i].properties.caseslist[j].Month,
                    "Year": tempLGAcenterofMonth.features[i].properties.caseslist[j].Year,
                    "cases": tempLGAcenterofMonth.features[i].properties.caseslist[j].cases,
                    "start": 360 / tempLGAcenterofMonth.features[i].properties.caseslist.length * j,
                    "end": 360 / tempLGAcenterofMonth.features[i].properties.caseslist.length * (j+1)

                })


            }
            tempLGAcenterofMonth.features[i].properties.caseslist = newtempcaseslist;
            //tempLGAcenterofMonth.features[i].push(newtempproperties);

        }
        console.log(tempLGAcenterofMonth);
        console.log(updatefeatures);
        console.log(finalcenterpoint); //need finalcenterpointallcaseslist

        var tempfinalcenterpoint = JSON.stringify(finalcenterpointallcaseslist);
        tempfinalcenterpointcopy = JSON.parse(tempfinalcenterpoint);

        for (let i = 0; i < finalcenterpointallcaseslist.length; i++){
            tempfinalcenterpointcopy[i].caseslist = finalcenterpointallcaseslist[i].caseslist.slice(updatefeatures.timelinelist[0], updatefeatures.timelinelist[1]);
        }

        // var tempfinalcenterpoint = JSON.stringify(finalcenterpoint);
        // tempfinalcenterpointcopy = JSON.parse(tempfinalcenterpoint);
        //
        // for (let i = 0; i < finalcenterpoint.length; i++){
        //     tempfinalcenterpointcopy[i].caseslist = finalcenterpoint[i].caseslist.slice(updatefeatures.timelinelist[0], updatefeatures.timelinelist[1]);
        // }
        for (let i = 0; i < tempfinalcenterpointcopy.length; i++){
            var newtempcaseslistforselected = [];

            for (let j = 0; j < tempfinalcenterpointcopy[i].caseslist.length; j++){
                newtempcaseslistforselected.push({
                    "Month": tempfinalcenterpointcopy[i].caseslist[j].Month,
                    "Year": tempfinalcenterpointcopy[i].caseslist[j].Year,
                    "cases": tempfinalcenterpointcopy[i].caseslist[j].cases,
                    "start": 360 / tempfinalcenterpointcopy[i].caseslist.length * j,
                    "end": 360 / tempfinalcenterpointcopy[i].caseslist.length * (j+1)

                })


            }
            tempfinalcenterpointcopy[i].caseslist = newtempcaseslistforselected;
            //tempLGAcenterofMonth.features[i].push(newtempproperties);

        }



        console.log("after drawoutput timeline");
        callback2(tempfinalcenterpointcopy, callback3);
    }

    //console.log(tempclustersinfo);

    function Draw(callback3){
        console.log("draw data")
        var nodes_clustered = d3.select('#group_nodecluster').selectAll(".node")
            .data(tempclustersinfo)
            .enter()
            .append("g")
            .attr('id', function(d, o) {
                //console.log(d);
                var tempstringlga = "";
                for (var i = 0; i < d.clusterlgacode.length; i++){
                    tempstringlga += d.clusterlgacode[i] + '-';
                }
                return 'nodecluster-' + tempstringlga;
            })
            .attr("class", "node")
            .attr("transform", function(data) {
                //console.log(data);
                return "translate(" + project(data.coordinates).x + "," + project(data.coordinates).y + ")";
            });
        nodes_clustered.each(function(temp) {
            // var pieflag = 0;
            //console.log(temp);
            //draw piesymbol
            var tempstringlgacode = "";
            for (var i = 0; i < temp.clusterlgacode.length; i++){
                tempstringlgacode += temp.clusterlgacode[i] + '-';
            }
            var piesymbol_cluster = d3.select('#nodecluster-' + tempstringlgacode).selectAll("path");
            //piesymbol = d3.select('#circle-' + temp.properties.lgacode).selectAll("path");
            piesymbol_cluster
                .data(function (d) {
                    //console.log(d);
                    return pie(d.caseslist);
                })
                .enter()
                .append("path")
                .attr("d", arc)
                .attr('id', function(d, o) {
                    //console.log(d);
                    //console.log(o);
                    return 'piebar-' + o;
                })
                .style("fill", function(d) {
                    //console.log(d);
                    if ( d.data.cases === 0)
                        return ColorGrey[0];
                    else
                        return Flowercolorpannel[0];
                })
                .style("fill-opacity", 1)
                //.attr("r", function(d) { return size(d.size)||nominal_base_node_size; })
                .style("stroke-width", 1)
                .style("stroke", "white")

                .on("mousemove",function(d,o){
                })

        });



        var nodes_unclustered = d3.select('#group_nodeuncluster').selectAll(".node")
            .data(tempLGAcenterofMonth.features)
            .enter()
            .append("g")
            .attr('id', function(d, i) {
                return 'nodeuncluster-' + d.properties.lgacode
            })
            .attr("class", "node")
            .attr("transform", function(data) {
                //console.log(data);
                return "translate(" + project(data.properties.geo_point_2d).x + "," + project(data.properties.geo_point_2d).y + ")";
            });
        var piesymbol_uncluster;
        nodes_unclustered.each(function(temp) {
            // var pieflag = 0;
            //console.log(temp);
            //draw piesymbol
            piesymbol_uncluster = d3.select('#nodeuncluster-' + temp.properties.lgacode).selectAll("path");
            //piesymbol = d3.select('#circle-' + temp.properties.lgacode).selectAll("path");
            piesymbol_uncluster
                .data(function (d) {
                    //console.log(d);
                    return pie(d.properties.caseslist);
                })
                .enter()
                .append("path")
                .attr("d", arc)
                .attr('id', function(d, o) {
                    //console.log(d);
                    //console.log(o);
                    return 'piebar-' + o;
                })
                .style("fill", function(d) {
                    //console.log(d);
                    if ( d.data.cases === 0)
                        return ColorGrey[0];
                    else
                        return Flowercolorpannel[0];
                })
                .style("fill-opacity", 1)
                //.attr("r", function(d) { return size(d.size)||nominal_base_node_size; })
                .style("stroke-width", 1)
                .style("stroke", "white")
                .on("mousemove",function(d,o){
                    // console.log(d);
                    // console.log(o);
                })

        });

        var dots_unclustered = d3.select('#group_nodeuncluster').selectAll("circle")
            .data(LGAcenterofMonth.features)
            .enter()
            .append("circle")
            .attr('id', function(d) {
                //console.log(d);
                return 'circleuncluster-' + d.properties.lgacode
            })
            .attr("r", 1)
            .attr("stroke", "#636363")
            .attr("stroke-dasharray", 0.5)
            .attr("fill", "#ffffff")
            .attr("fill-opacity", 0)
            .attr("cx", function(data) {
                return project(data.properties.geo_point_2d).x;
            })
            .attr("cy", function(data) {
                return project(data.properties.geo_point_2d).y;
            })
            .on("click", function (d){
                if (d3.event.defaultPrevented) {
                    return;
                }
                //console.log(d);
            })
            .on("mousemove", function (d) {
                //console.log(d);
                //divlegend.style("display","none");
                let tempstringformonthdata = ""
                let count = 0;
                for (let i = 0; i < d.properties.caseslist.length; i++){
                    tempstringformonthdata += "Month:" + d.properties.caseslist[i].Month + ", Cases:" + d.properties.caseslist[i].cases + "</br>";
                    count ++;
                }

                // divlegend.html("Name: "+ d.properties.name +"</br> LGAcode: "+  d.properties.lgacode +"</br>" + tempstringformonthdata)
                //
                //     .style("left", (d3.event.pageX+12) + "px")
                //     .style("top", (d3.event.pageY-10) + "px")
                //     .style("opacity", 0.8)
                //     .style("height", function(){
                //         //console.log(tempevents);
                //         return 22 * (count + 1) + 'px';
                //     })
                //     .style("display","block");
            })
            .on("mouseout",function(d,o){
                //divlegend.style("display","none");

            });

        console.log("after draw data")
        callback3();

    }

    function Drawupdate(){
        console.log("draw data updated ")
        //console.log(mapboxDynamicCluster); //all cluster points
        // console.log(tempLGAcenterofMonth); //all unclustered points
        // console.log(LGAcenterofMonth); // all point data
        // console.log(tempclustersinfo); // all cluster details

        d3.select('#group_nodecluster').selectAll(".node").remove();
        d3.select('#group_nodeuncluster').selectAll(".node").remove();
        var nodes_clustered = d3.select('#group_nodecluster').selectAll(".node")
            .data(tempclustersinfo)
            .enter()
            .append("g")
            .attr('id', function(d, o) {
                //console.log(d);
                var tempstringlga = "";
                for (var i = 0; i < d.clusterlgacode.length; i++){
                    tempstringlga += d.clusterlgacode[i] + '-';
                }
                return 'nodecluster-' + tempstringlga;
            })
            .attr("class", "node")
            .attr("transform", function(data) {
                //console.log(data);
                return "translate(" + project(data.coordinates).x + "," + project(data.coordinates).y + ")";
            });
        nodes_clustered.each(function(temp) {
            // var pieflag = 0;
            //console.log(temp);
            //draw piesymbol
            var tempstringlgacode = "";
            for (var i = 0; i < temp.clusterlgacode.length; i++){
                tempstringlgacode += temp.clusterlgacode[i] + '-';
            }
            var piesymbol_cluster = d3.select('#nodecluster-' + tempstringlgacode).selectAll("path");
            //piesymbol = d3.select('#circle-' + temp.properties.lgacode).selectAll("path");
            piesymbol_cluster
                .data(function (d) {
                    //console.log(d);
                    return pie(d.caseslist);
                })
                .enter()
                .append("path")
                .attr("d", arc)
                .attr('id', function(d, o) {
                    //console.log(d);
                    //console.log(o);
                    return 'piebar-' + o;
                })
                .style("fill", function(d) {
                    //console.log(d);
                    if ( d.data.cases === 0)
                        return ColorGrey[0];
                    else
                        return Flowercolorpannel[0];
                })
                .style("fill-opacity", 1)
                //.attr("r", function(d) { return size(d.size)||nominal_base_node_size; })
                .style("stroke-width", 1)
                .style("stroke", "white")
                .on("mousemove",function(d,o){
                })

        });
        //console.log(tempLGAcenterofMonth.features);
        var nodes_unclustered = d3.select('#group_nodeuncluster').selectAll(".node")
            .data(tempLGAcenterofMonth.features)
            .enter()
            .append("g")
            .attr('id', function(d, i) {
                return 'nodeuncluster-' + d.properties.lgacode
            })
            .attr("class", "node")
            .attr("transform", function(data) {
                //console.log(data);
                return "translate(" + project(data.properties.geo_point_2d).x + "," + project(data.properties.geo_point_2d).y + ")";
            });
        var piesymbol_uncluster;
        nodes_unclustered.each(function(temp) {
            // var pieflag = 0;
            //console.log(temp);
            //draw piesymbol
            piesymbol_uncluster = d3.select('#nodeuncluster-' + temp.properties.lgacode).selectAll("path");
            //piesymbol = d3.select('#circle-' + temp.properties.lgacode).selectAll("path");
            piesymbol_uncluster
                .data(function (d) {
                    //console.log(d);
                    return pie(d.properties.caseslist);
                })
                .enter()
                .append("path")
                .attr("d", arc)
                .attr('id', function(d, o) {
                    //console.log(d);
                    //console.log(o);
                    return 'piebar-' + o;
                })
                .style("fill", function(d) {
                    //console.log(d);
                    if ( d.data.cases === 0)
                        return ColorGrey[0];
                    else
                        return Flowercolorpannel[0];
                })
                .style("fill-opacity", 1)
                //.attr("r", function(d) { return size(d.size)||nominal_base_node_size; })
                .style("stroke-width", 1)
                .style("stroke", "white")
                .on("mousemove",function(d,o){
                    // console.log(d);
                    // console.log(o);
                })

        });
        //console.log(tempnode);
        //console.log(piesymbol_uncluster);


        //disvisible grouped LGAs
        console.log(templgacodestore);
        for (let i = 0; i < templgacodestore.length; i ++){

            var tempstringlgacode = templgacodestore[i] + '-';
            var len = tempstringlgacode.split("-").length-1
            if (len > 1){
                var piesymbol_cluster = d3.select('#nodecluster-' + tempstringlgacode).selectAll("path");
                //piesymbol = d3.select('#circle-' + temp.properties.lgacode).selectAll("path");
                piesymbol_cluster.style("opacity", 0)
            }
            else{
                var piesymbol_uncluster = d3.select('#nodeuncluster-' + templgacodestore[i]).selectAll("path");
                piesymbol_uncluster.style("opacity", 0)
            }

        }

    }

    function DrawupdatebyTimeline(tempfinalcenterpointcopy){
        console.log("draw data updated timeline");


        console.log(updatefeatures.features);

        // console.log(mapboxDynamicCluster); //all cluster points
        console.log(tempLGAcenterofMonth.features); //all unclustered points
        // console.log(LGAcenterofMonth); // all point data
        console.log(tempclustersinfo); // all cluster details
        console.log(tempfinalcenterpointcopy); // all grouped details
        console.log(finalcenterpoint);

        d3.select('#group_nodecluster').selectAll(".node").remove();

        d3.select('#group_nodeuncluster').selectAll(".node").remove();

        d3.select('#group_nodeuncluster').selectAll("circle").remove();

        group_select.selectAll("circle").remove();
        group_select.selectAll(".node").remove();

        var nodes_clustered = d3.select('#group_nodecluster').selectAll(".node")
            .data(tempclustersinfo)
            .enter()
            .append("g")
            .attr('id', function(d, o) {
                //console.log(d);
                var tempstringlga = "";
                for (var i = 0; i < d.clusterlgacode.length; i++){
                    tempstringlga += d.clusterlgacode[i] + '-';
                }
                return 'nodecluster-' + tempstringlga;
            })
            .attr("class", "node")
            .attr("transform", function(data) {
                //console.log(data);
                return "translate(" + project(data.coordinates).x + "," + project(data.coordinates).y + ")";
            });
        nodes_clustered.each(function(temp) {
            // var pieflag = 0;
            //console.log(temp);
            //draw piesymbol
            var tempstringlgacode = "";
            for (var i = 0; i < temp.clusterlgacode.length; i++){
                tempstringlgacode += temp.clusterlgacode[i] + '-';
            }
            var piesymbol_cluster = d3.select('#nodecluster-' + tempstringlgacode).selectAll("path");
            //piesymbol = d3.select('#circle-' + temp.properties.lgacode).selectAll("path");
            piesymbol_cluster
                .data(function (d) {
                    //console.log(d.caseslist);
                    return pie(d.caseslist);
                })
                .enter()
                .append("path")
                .attr("d", arc)
                .attr('id', function(d, o) {
                    //console.log(d);
                    //console.log(o);
                    return 'piebar-' + o;
                })
                .style("fill", function(d) {
                    //console.log(d);
                    if ( d.data.cases === 0)
                        return ColorGrey[0];
                    else
                        return Flowercolorpannel[0];
                })
                .style("fill-opacity", 1)
                //.attr("r", function(d) { return size(d.size)||nominal_base_node_size; })
                .style("stroke-width", 1)
                .style("stroke", "white")
                .on("mousemove",function(d,o){
                })

        });

        // console.log(tempclustersinfo);
        // console.log(updatefeatures.features);
        // console.log(tempLGAcenterofMonth.features);


        //console.log(tempLGAcenterofMonth.features);
        var nodes_unclustered = d3.select('#group_nodeuncluster').selectAll(".node")
            .data(tempLGAcenterofMonth.features)
            .enter()
            .append("g")
            .attr('id', function(d, i) {
                return 'nodeuncluster-' + d.properties.lgacode
            })
            .attr("class", "node")
            .attr("transform", function(data) {
                //console.log(data);
                return "translate(" + project(data.properties.geo_point_2d).x + "," + project(data.properties.geo_point_2d).y + ")";
            });
        var piesymbol_uncluster;
        nodes_unclustered.each(function(temp) {
            // var pieflag = 0;
            //console.log(temp);
            //draw piesymbol
            piesymbol_uncluster = d3.select('#nodeuncluster-' + temp.properties.lgacode).selectAll("path");
            //piesymbol = d3.select('#circle-' + temp.properties.lgacode).selectAll("path");
            piesymbol_uncluster
                .data(function (d) {
                    //console.log(d.properties.caseslist);
                    return pie(d.properties.caseslist);
                })
                .enter()
                .append("path")
                .attr("d", arc)
                .attr('id', function(d, o) {
                    //console.log(d);
                    //console.log(o);
                    return 'piebar-' + o;
                })
                .style("fill", function(d) {
                    //console.log(d);
                    if ( d.data.cases === 0)
                        return ColorGrey[0];
                    else
                        return Flowercolorpannel[0];
                })
                .style("fill-opacity", 1)
                //.attr("r", function(d) { return size(d.size)||nominal_base_node_size; })
                .style("stroke-width", 1)
                .style("stroke", "white")
                .on("mousemove",function(d,o){
                    // console.log(d);
                    // console.log(o);
                })

        });
        //console.log(tempnode);
        //console.log(piesymbol_uncluster);


        //disvisible grouped LGAs
        //console.log(templgacodestore);
        for (let i = 0; i < templgacodestore.length; i ++){

            var tempstringlgacode = templgacodestore[i] + '-';
            var len = tempstringlgacode.split("-").length - 1;
            if (len > 1){
                var piesymbol_cluster = d3.select('#nodecluster-' + tempstringlgacode).selectAll("path");
                //piesymbol = d3.select('#circle-' + temp.properties.lgacode).selectAll("path");
                piesymbol_cluster.style("opacity", 0)
            }
            else{
                var piesymbol_uncluster = d3.select('#nodeuncluster-' + templgacodestore[i]).selectAll("path");
                piesymbol_uncluster.style("opacity", 0)
            }

        }


        var centredot = group_select.selectAll("circle")
            .data(tempfinalcenterpointcopy)
            .enter()
            .append("circle")
            .attr("r", 10)
            .attr("stroke", "#636363")
            .attr("stroke-dasharray", 0.5)
            .attr("fill", mapcirclecolor[2])
            .attr("fill-opacity", 1)
            //
            .attr("cx", function(data) {
                //console.log(data);
                return project(data.coordinates).x;
            })
            .attr("cy", function(data) {
                return project(data.coordinates).y;
            })
            .on("mousemove", function (d) {
                //console.log(d);
                var templgaarr = d.clusterlgacode.split("-");
                map.setFilter('polygon-highlighted', ['in', 'lgacode', ...templgaarr]);
            })
            .on("mouseout",function(d,o){
                map.setFilter('polygon-highlighted', ['in', 'lgacode', '']);
            });


        var nodes_selected = group_select.selectAll(".node")
            .data(tempfinalcenterpointcopy)
            .enter()
            .append("g")
            .attr('id', function(d, o) {
                return 'nodeselect-' + d.clusterlgacode;
            })
            .attr("class", "node")
            .attr("transform", function(data) {
                //console.log(data);
                return "translate(" + project(data.coordinates).x + "," + project(data.coordinates).y + ")";
            });

        nodes_selected.each(function(temp) {
            // var pieflag = 0;
            //console.log(temp);
            //draw piesymbol
            var tempstringlgacode = temp.clusterlgacode;
            var piesymbol_cluster = d3.select('#nodeselect-' + tempstringlgacode).selectAll("path");
            //piesymbol = d3.select('#circle-' + temp.properties.lgacode).selectAll("path");
            piesymbol_cluster
                .data(function (d) {
                    //console.log(d);
                    return pie(d.caseslist);
                })
                .enter()
                .append("path")
                .attr("d", arc)
                .attr('id', function(d, o) {
                    //console.log(d);
                    //console.log(o);
                    return 'piebar-' + o;
                })
                .style("fill", function(d) {
                    //console.log(d);
                    if ( d.data.cases === 0)
                        return ColorGrey[0];
                    else
                        return Flowercolorpannel[0];
                })
                .style("fill-opacity", 1)
                //.attr("r", function(d) { return size(d.size)||nominal_base_node_size; })
                .style("stroke-width", 1)
                .style("stroke", "white")
                .on("mousemove",function(d,o){
                })
        });



    }

    function updateArea(e) {
        areaflag = 1;
        //this function used to display fixed flower on map by filtered timeline
        //该函数用当前的时间线来过滤地图上的花，不对时间进行操作，其中操作包括计算grouped的点的类型，获取所有clustered的下属点，cases加和，隐去选中的点之前的花

        clusterarr = [];
        //otherclusterarr = [];
        var selectedarr = []; //负责存储当前选中的点的array
        var selectedarrforAllcaseslist = [];

        //Query selected elements
        var draw_polygon = turf.bbox(e.features[0]);
        var southWest = [draw_polygon[0], draw_polygon[1]];
        var northEast = [draw_polygon[2], draw_polygon[3]];

        var northEastPointPixel = map.project(northEast);
        var southWestPointPixel = map.project(southWest);

        var features_cluster = map.queryRenderedFeatures([southWestPointPixel, northEastPointPixel], { layers: ['lga-center-clustered'] });
        var features_uncluster = map.queryRenderedFeatures([southWestPointPixel, northEastPointPixel], { layers: ['lga-center-unclustered'] });

        //如果未选中点，返回
        if ((features_uncluster.length === 0) && (features_cluster.length === 0) ) {
            return;
        }

        if (tickflag === 0){
            //判断是否点击过保存，如果保存过获取当前未被选中的所有聚类和非聚类的点
            var features_allcluster = map.queryRenderedFeatures({ layers: ['lga-center-clustered'] });
            var features_alluncluster = map.queryRenderedFeatures({ layers: ['lga-center-unclustered'] });
            console.log(tickflag, clusterdiff, unclusterdiff);
            tickflag = 1;
        }
        else
        {
            var features_allcluster = clusterdiff;
            var features_alluncluster = unclusterdiff;
            console.log(tickflag, clusterdiff, unclusterdiff);
        }

        clusterdiff = getDifferenceSet(features_cluster, features_allcluster, 'id');
        unclusterdiff = getDifferenceSetLGAcode(features_uncluster, features_alluncluster);
        //获取了当前所有未被选中的聚类/非聚类的点
        console.log(clusterdiff);
        console.log(unclusterdiff);

        //获取时间线，判断是否点击过时间线变化按钮
        var tempnumber;

        if (timelineflag == 0){
            tempnumber = 25;
            temptimearr[0] = 0;
            temptimearr[1] = 25;
        }
        else if (timelineflag == 1){
            tempnumber = Number(updatefeatures.timelinelist[1]) -  Number(updatefeatures.timelinelist[0]);
            temptimearr[0] = Number(updatefeatures.timelinelist[0]);
            temptimearr[1] = Number(updatefeatures.timelinelist[1]);
        }


        // console.log(tempnumber);
        var selectcallBack = function(clusterdiff, unclusterdiff, clusterarr, features_uncluster, callback) {
            //后续处理
            console.log("selectcallback");
            console.log(features_uncluster); //所有unclustered，时间为当前时间段数据？
            console.log(clusterarr);//所有clustered数组，时间为全数据？
            mapsavegroups = [];
            mapsavegroupsforallcaseslist = [];
            //document.getElementById('features').innerHTML = JSON.stringify(clusterarr,null, 2) + unclusterstring;
            console.log(updatefeatures); //时间为当前时间段数据？

            //console.log(tempnumber2);
            //var tempmonth = new Array(tempnumber).fill(0); //coresponding to the maxnumber

            var templgacodeset = [];
            //var tempmontheach = new Array(24).fill(0);
            //templgacodestore = [];

            for (var x = 0; x < features_uncluster.length; x ++){
                var uppername = features_uncluster[x].properties.name.toLowerCase();
                selectedarr.push({
                    "name": uppername.charAt(0).toUpperCase() + uppername.slice(1),
                    "coordinates": features_uncluster[x].geometry.coordinates,
                    "status": "unclustered",
                    "caseslist": JSON.parse(features_uncluster[x].properties.caseslist),
                    "lgacode": features_uncluster[x].properties.lgacode
                });
                //selectedarrforAllcaseslist
                selectedarrforAllcaseslist.push({
                    "name": uppername.charAt(0).toUpperCase() + uppername.slice(1),
                    "coordinates": features_uncluster[x].geometry.coordinates,
                    "status": "unclustered",
                    "caseslist": JSON.parse(features_uncluster[x].properties.caseslist),
                    "lgacode": features_uncluster[x].properties.lgacode
                });
                templgacodeset.push({
                    "lgacode": features_uncluster[x].properties.lgacode,
                    "caseslist": JSON.parse(features_uncluster[x].properties.caseslist)
                });
                templgacodestore.push(features_uncluster[x].properties.lgacode);

            }
            //console.log(temptimearr);

            for (var i = 0; i < clusterarr.length; i ++){
                var tempstring = "";
                var tempmonth = new Array(25).fill(0);
                for (var j = 0; j < clusterarr[i].length; j ++)
                {
                    var uppername = clusterarr[i][j].properties.name.toLowerCase();
                    selectedarr.push({
                        "name": uppername.charAt(0).toUpperCase() + uppername.slice(1),
                        "coordinates": clusterarr[i][j].geometry.coordinates,
                        "status": "clustered",
                        "caseslist": clusterarr[i][j].properties.caseslist.slice(temptimearr[0], temptimearr[1]),
                        "lgacode": clusterarr[i][j].properties.lgacode
                    });
                    selectedarrforAllcaseslist.push({
                        "name": uppername.charAt(0).toUpperCase() + uppername.slice(1),
                        "coordinates": clusterarr[i][j].geometry.coordinates,
                        "status": "clustered",
                        "caseslist": clusterarr[i][j].properties.caseslist,
                        "lgacode": clusterarr[i][j].properties.lgacode
                    });
                    tempstring += clusterarr[i][j].properties.lgacode + "-";
                    for (var k = 0; k < clusterarr[i][j].properties.caseslist.length; k++){
                        // if (clusterarr[i][j].properties.caseslist[k]["Month"] === k + 1)
                        tempmonth[k] += clusterarr[i][j].properties.caseslist[k]["cases"];
                    }

                }
                templgacodeset.push({
                    "lgacode": tempstring.substring(0, tempstring.length - 1),
                    "caseslist": tempmonth.slice(temptimearr[0], temptimearr[1])
                });
                templgacodestore.push(tempstring.substring(0, tempstring.length - 1));

            }
            console.log(selectedarr);
            mapsavegroups.push(selectedarr);
            mapsavegroupsforallcaseslist.push(selectedarrforAllcaseslist);
            console.log(mapsavegroups);


            for (var i = 0; i < mapsavegroups.length; i++){
                var temp_x = 0, temp_y=0;
                var count = 0;
                var centrepointstring = "";
                var centrepointlgastring = "";
                var centrepointcaseslist = new Array(tempnumber).fill(0);
                //var centrepointalllgacode = []; tempnumber

                for (let a = 0; a < mapsavegroups[i].length; a ++)
                {
                    //console.log(selectedarr[a]);
                    temp_x += Number(mapsavegroups[i][a].coordinates[0]);
                    temp_y += Number(mapsavegroups[i][a].coordinates[1]);
                    count ++;
                    centrepointstring += mapsavegroups[i][a].name + ", ";
                    centrepointlgastring += mapsavegroups[i][a].lgacode + "-";
                    for (let k = 0; k < mapsavegroups[i][a].caseslist.length; k++){
                        // if (mapsavegroups[i][a].caseslist[k]["Month"] === k + 1){
                        if (mapsavegroups[i][a].status === "unclustered"){
                            centrepointcaseslist[k] += mapsavegroups[i][a].caseslist[k]["cases"];
                        }
                        else
                        {
                            centrepointcaseslist[k] += mapsavegroups[i][a].caseslist[k]["cases"];
                        }
                        // }
                    }
                    //centrepointalllgacode.push(selectedarr[a].lgacode);
                }

                var centre_coordinates = [temp_y / count, temp_x / count];
                //console.log(centre_coordinates);
                centrepoint.push({
                    "name": centrepointstring.substring(0, centrepointstring.length - 2),
                    "lgacode": templgacodestore,
                    "coordinates": centre_coordinates,
                    "caseslist": centrepointcaseslist

                });
                // console.log(temp_x);
                // console.log(temp_y);
                //console.log(centrepoint);
                //console.log();
                var templgasum = [];
                for (var l = 0; l < centrepointcaseslist.length; l++){
                    templgasum.push({
                        "Month": l + 1,
                        "cases": centrepointcaseslist[l],
                        "start": 360 / centrepointcaseslist.length * l,
                        "end": 360 / centrepointcaseslist.length * (l+1)
                    });
                }

                finalcenterpoint.push({
                    "clusterlgacode" : centrepointlgastring.substring(0, centrepointlgastring.length - 1),
                    "clustername" : centrepointstring.substring(0, centrepointstring.length - 2),
                    "coordinates" : centre_coordinates,
                    "count": selectedarr.length,
                    "caseslist": templgasum
                });

                //console.log(project(centrepoint[0].coordinates)); //centre of calculate point
            }

            for (var i = 0; i < mapsavegroupsforallcaseslist.length; i++){
                var temp_x = 0, temp_y=0;
                var count = 0;
                var centrepointstring = "";
                var centrepointlgastring = "";
                var centrepointcaseslist = new Array(25).fill(0);
                //var centrepointalllgacode = []; tempnumber

                for (let a = 0; a < mapsavegroupsforallcaseslist[i].length; a ++)
                {
                    //console.log(selectedarr[a]);
                    temp_x += Number(mapsavegroupsforallcaseslist[i][a].coordinates[0]);
                    temp_y += Number(mapsavegroupsforallcaseslist[i][a].coordinates[1]);
                    count ++;
                    centrepointstring += mapsavegroupsforallcaseslist[i][a].name + ", ";
                    centrepointlgastring += mapsavegroupsforallcaseslist[i][a].lgacode + "-";
                    for (let k = 0; k < mapsavegroupsforallcaseslist[i][a].caseslist.length; k++){
                        // if (mapsavegroups[i][a].caseslist[k]["Month"] === k + 1){
                        if (mapsavegroupsforallcaseslist[i][a].status === "unclustered"){
                            centrepointcaseslist[k] += mapsavegroupsforallcaseslist[i][a].caseslist[k]["cases"];
                        }
                        else
                        {
                            centrepointcaseslist[k] += mapsavegroupsforallcaseslist[i][a].caseslist[k]["cases"];
                        }
                        // }
                    }
                    //centrepointalllgacode.push(selectedarr[a].lgacode);
                }

                var centre_coordinates = [temp_y / count, temp_x / count];
                //console.log(centre_coordinates);
                centrepointallcaseslist.push({
                    "name": centrepointstring.substring(0, centrepointstring.length - 2),
                    "lgacode": templgacodestore,
                    "coordinates": centre_coordinates,
                    "caseslist": centrepointcaseslist

                });
                // console.log(temp_x);
                // console.log(temp_y);
                //console.log(centrepoint);
                //console.log();
                var templgasum = [];
                for (var l = 0; l < centrepointcaseslist.length; l++){
                    templgasum.push({
                        "Month": l + 1,
                        "cases": centrepointcaseslist[l],
                        "start": 360 / centrepointcaseslist.length * l,
                        "end": 360 / centrepointcaseslist.length * (l+1)
                    });
                }

                finalcenterpointallcaseslist.push({
                    "clusterlgacode" : centrepointlgastring.substring(0, centrepointlgastring.length - 1),
                    "clustername" : centrepointstring.substring(0, centrepointstring.length - 2),
                    "coordinates" : centre_coordinates,
                    "count": selectedarr.length,
                    "caseslist": templgasum
                });

                //console.log(project(centrepoint[0].coordinates)); //centre of calculate point
            }


            deWeightCluster(finalcenterpoint);
            deWeightCluster(finalcenterpointallcaseslist);
            console.log(finalcenterpointallcaseslist);
            // console.log(finalcenterpoint); //计算后的当前所有group节点数据
            // console.log(features_uncluster);
            // console.log(clusterarr);
            // console.log(otherclusterarr);

            for (let i = 0; i < templgacodestore.length; i ++){

                var tempstringlgacode = templgacodestore[i] + '-';
                var len = tempstringlgacode.split("-").length-1
                if (len > 1){
                    var piesymbol_cluster = d3.select('#nodecluster-' + tempstringlgacode).selectAll("path");
                    //piesymbol = d3.select('#circle-' + temp.properties.lgacode).selectAll("path");
                    piesymbol_cluster.style("opacity", 0)
                }
                else{
                    var piesymbol_uncluster = d3.select('#nodeuncluster-' + templgacodestore[i]).selectAll("path");
                    piesymbol_uncluster.style("opacity", 0)
                }

            }

            // .attr("cx", project(centrepoint.coordinates).x)
            // .attr("cy", project(centrepoint.coordinates).y)

            //console.log(centredot);
            // console.log(dots);
            //render();

            //计算筛选后的clustered包含的数据
            var c = 0;
            otherclusterarr = [];
            for (var b = 0; b < clusterdiff.length; b++) {
                //console.log(clusterdiff.length);
                //console.log(features_cluster[i]);
                var clusterId = clusterdiff[b].properties.cluster_id,
                    point_count = clusterdiff[b].properties.point_count,
                    clusterSource = map.getSource('lga-center-clustered-copy');
                //console.log(clusterSource);
                // Get all points under a cluster

                var pt= clusterSource.getClusterLeaves(clusterId, point_count, 0, (err, aFeatures) =>{
                    otherclusterarr.push(aFeatures);
                    console.log('here3')
                    // console.log(clusterarr);
                    //console.log(clusterarr);
                    c ++;
                    //console.log(j);
                    if (clusterdiff.length === c ){
                        console.log('here4')
                        // console.log(clusterarr);
                        setTimeout(callback(), 0)
                        //return;
                    }

                })
                //console.log(i);
                // console.log(pt)

            }
            //setTimeout(callback(), 0)

            //console.log(otherclusterarr);

        }

        var DrawSelectCallBack = function(){
            console.log("Drawselectcallback");

            var centredot = group_select.selectAll("circle")
                .data(finalcenterpoint)
                .enter()
                .append("circle")
                .attr("r", 10)
                .attr("stroke", "#636363")
                .attr("stroke-dasharray", 0.5)
                .attr("fill", mapcirclecolor[2])
                .attr("fill-opacity", 1)
                //
                .attr("cx", function(data) {
                    //console.log(data);
                    return project(data.coordinates).x;
                })
                .attr("cy", function(data) {
                    return project(data.coordinates).y;
                })
                .on("mousemove", function (d) {
                    //console.log(d);
                    var templgaarr = d.clusterlgacode.split("-");
                    map.setFilter('polygon-highlighted', ['in', 'lgacode', ...templgaarr]);
                })
                .on("mouseout",function(d,o){
                    map.setFilter('polygon-highlighted', ['in', 'lgacode', '']);
                });


            var nodes_selected = group_select.selectAll(".node")
                .data(finalcenterpoint)
                .enter()
                .append("g")
                .attr('id', function(d, o) {
                    return 'nodeselect-' + d.clusterlgacode;
                })
                .attr("class", "node")
                .attr("transform", function(data) {
                    //console.log(data);
                    return "translate(" + project(data.coordinates).x + "," + project(data.coordinates).y + ")";
                });

            nodes_selected.each(function(temp) {
                // var pieflag = 0;
                //console.log(temp);
                //draw piesymbol
                var tempstringlgacode = temp.clusterlgacode;
                var piesymbol_cluster = d3.select('#nodeselect-' + tempstringlgacode).selectAll("path");
                //piesymbol = d3.select('#circle-' + temp.properties.lgacode).selectAll("path");
                piesymbol_cluster
                    .data(function (d) {
                        //console.log(d);
                        return pie(d.caseslist);
                    })
                    .enter()
                    .append("path")
                    .attr("d", arc)
                    .attr('id', function(d, o) {
                        //console.log(d);
                        //console.log(o);
                        return 'piebar-' + o;
                    })
                    .style("fill", function(d) {
                        //console.log(d);
                        if ( d.data.cases === 0)
                            return ColorGrey[0];
                        else
                            return Flowercolorpannel[0];
                    })
                    .style("fill-opacity", 1)
                    //.attr("r", function(d) { return size(d.size)||nominal_base_node_size; })
                    .style("stroke-width", 1)
                    .style("stroke", "white")
                    .on("mousemove",function(d,o){
                    })
            });
        }

        if ((features_cluster.length > 0) || (features_uncluster.length > 0)){
            //如果圈选中的聚类/非聚类的点不为0，callback到获取cluster点的函数中,传递参数为：未被圈选的聚类点/未被圈选的非聚类点/被圈选的聚类点/被圈选的非聚类点
            Findclusterbycallback(clusterdiff, unclusterdiff, features_cluster, features_uncluster, selectcallBack, DrawSelectCallBack)

        }


    }

    function updateAreaAfterDelete(e){
        console.log("draw data updated")
        //console.log(mapboxDynamicCluster); //all cluster points
        // console.log(tempLGAcenterofMonth); //all unclustered points
        // console.log(LGAcenterofMonth); // all point data
        // console.log(tempclustersinfo); // all cluster details

        d3.select('#group_nodecluster').selectAll(".node").remove();
        d3.select('#group_nodeuncluster').selectAll(".node").remove();
        d3.select('#group_nodeselect').remove();

        var nodes_clustered = d3.select('#group_nodecluster').selectAll(".node")
            .data(tempclustersinfo)
            .enter()
            .append("g")
            .attr('id', function(d, o) {
                //console.log(d);
                var tempstringlga = "";
                for (var i = 0; i < d.clusterlgacode.length; i++){
                    tempstringlga += d.clusterlgacode[i] + '-';
                }
                return 'nodecluster-' + tempstringlga;
            })
            .attr("class", "node")
            .attr("transform", function(data) {
                //console.log(data);
                return "translate(" + project(data.coordinates).x + "," + project(data.coordinates).y + ")";
            });
        nodes_clustered.each(function(temp) {
            // var pieflag = 0;
            //console.log(temp);
            //draw piesymbol
            var tempstringlgacode = "";
            for (var i = 0; i < temp.clusterlgacode.length; i++){
                tempstringlgacode += temp.clusterlgacode[i] + '-';
            }
            var piesymbol_cluster = d3.select('#nodecluster-' + tempstringlgacode).selectAll("path");
            //piesymbol = d3.select('#circle-' + temp.properties.lgacode).selectAll("path");
            piesymbol_cluster
                .data(function (d) {
                    //console.log(d);
                    return pie(d.caseslist);
                })
                .enter()
                .append("path")
                .attr("d", arc)
                .attr('id', function(d, o) {
                    //console.log(d);
                    //console.log(o);
                    return 'piebar-' + o;
                })
                .style("fill", function(d) {
                    //console.log(d);
                    if ( d.data.cases === 0)
                        return ColorGrey[0];
                    else
                        return Flowercolorpannel[0];
                })
                .style("fill-opacity", 1)
                //.attr("r", function(d) { return size(d.size)||nominal_base_node_size; })
                .style("stroke-width", 1)
                .style("stroke", "white")
                .on("mousemove",function(d,o){
                })

        });

        var nodes_unclustered = d3.select('#group_nodeuncluster').selectAll(".node")
            .data(tempLGAcenterofMonth.features)
            .enter()
            .append("g")
            .attr('id', function(d, i) {
                return 'nodeuncluster-' + d.properties.lgacode
            })
            .attr("class", "node")
            .attr("transform", function(data) {
                //console.log(data);
                return "translate(" + project(data.properties.geo_point_2d).x + "," + project(data.properties.geo_point_2d).y + ")";
            });
        var piesymbol_uncluster;
        nodes_unclustered.each(function(temp) {
            // var pieflag = 0;
            //console.log(temp);
            //draw piesymbol
            piesymbol_uncluster = d3.select('#nodeuncluster-' + temp.properties.lgacode).selectAll("path");
            //piesymbol = d3.select('#circle-' + temp.properties.lgacode).selectAll("path");
            piesymbol_uncluster
                .data(function (d) {
                    //console.log(d);
                    return pie(d.properties.caseslist);
                })
                .enter()
                .append("path")
                .attr("d", arc)
                .attr('id', function(d, o) {
                    //console.log(d);
                    //console.log(o);
                    return 'piebar-' + o;
                })
                .style("fill", function(d) {
                    //console.log(d);
                    if ( d.data.cases === 0)
                        return ColorGrey[0];
                    else
                        return Flowercolorpannel[0];
                })
                .style("fill-opacity",1)
                //.attr("r", function(d) { return size(d.size)||nominal_base_node_size; })
                .style("stroke-width", 1)
                .style("stroke", "white")
                .on("mousemove",function(d,o){
                    // console.log(d);
                    // console.log(o);
                })

        });
    }

    function Findclusterbycallback(clusterdiff, unclusterdiff, features_cluster, features_uncluster, callBack1, callback2){
        console.log('Findclusterbycallback');
        //console.log(features_uncluster);
        //clusterstring = '';
        //获取grouped node中有哪些clustered LGA nodes
        var j = 0;
        if (features_cluster.length > 0){
            for (var i = 0; i < features_cluster.length; i++) {
                //console.log(features_cluster.length);
                //console.log(features_cluster[i]);
                var clusterId = features_cluster[i].properties.cluster_id,
                    point_count = features_cluster[i].properties.point_count,
                    clusterSource = map.getSource('lga-center-clustered-copy');
                //console.log(clusterSource);
                // Get all points under a cluster

                var pt= clusterSource.getClusterLeaves(clusterId, point_count, 0, (err, aFeatures) =>{
                    clusterarr.push(aFeatures); //获取被grouped的所有clustered nodes
                    console.log('here')
                    // console.log(clusterarr);
                    //console.log(clusterarr);
                    j ++;
                    //console.log(j);
                    if (features_cluster.length === j ){
                        console.log('here2')
                        // console.log(clusterarr);
                        setTimeout(callBack1(clusterdiff, unclusterdiff, clusterarr, features_uncluster, callback2), 50)
                        //clearInterval(ss);
                        //return;
                    }
                    //console.log('getClusterLeaves', err, aFeatures);
                    // clusterstring += JSON.stringify(
                    //     aFeatures,
                    //     null,
                    //     2
                    // );
                })
                //console.log(i);
                // console.log(pt)

            }
        }
        if ((features_uncluster.length >0) && (features_cluster.length == 0)){
            callBack1(clusterdiff, unclusterdiff, clusterarr, features_uncluster, callback2)
        }

        //setTimeout(callBack1(clusterdiff, unclusterdiff, clusterarr, callback2), 0)

        //setTimeout(callBack1(clusterarr, callback2), 0);
    }
    function project(data) {
        return map.project(new mapboxgl.LngLat(data[1], data[0]));
    }
    function projectxy(data) {
        return map.project(new mapboxgl.LngLat(data[0], data[1]));
    }

    function QueryHighlightPolygons(mapboxHighlightPolygonPoints, e, callback1, callback2){
        console.log('query highlight');

        return new Promise((resolve,reject)=>{

            // console.log("do calcsub");
            var clusterId = e.properties.cluster_id,
                point_count = e.properties.point_count,
                clusterSource = map.getSource('lga-center-clustered');
            //
            // // Get Next level cluster Children
            // //
            clusterSource.getClusterLeaves(clusterId, point_count, 0, function (err, aFeatures) {
                //console.log(aFeatures);

                mapboxHighlightPolygonPoints.push(aFeatures);
                //console.log(mapboxDynamicCluster);

                // console.log("after calcsub");
                resolve();
                console.log("run hightlight promise");
                callback1(mapboxHighlightPolygonPoints, callback2);
                //callback(e);
            });
        });
    }

    async function Polygonscallback(mapboxHighlightPolygonPoints, callback2){
        console.log('query highlight callback');
        //console.log(mapboxHighlightPolygonPoints);
        mapboxtempPolygonPoints = [];
        for (let i = 0; i < mapboxHighlightPolygonPoints[0].length; i++) {

            await PolygonsFind(mapboxHighlightPolygonPoints[0][i])

        }
        callback2(mapboxtempPolygonPoints);
    }

    function PolygonsFind(data){
        console.log('find highlight polygons');
        //console.log(data);
        var temp = projectxy(data.geometry.coordinates);
        var tempfeatures = map.queryRenderedFeatures(temp, {
            layers: ['polygon-fill']
        })
        //console.log(tempfeatures[0]);

        mapboxtempPolygonPoints.push(tempfeatures[0]);
        //console.log(mapboxtempPolygonPoints);

    }
    function PolygonscallbackAgain(data){
        console.log('query highlight callback again');
        //console.log(mapboxtempPolygonPoints);
        var templgacodes = [];
        for (let i = 0; i < mapboxtempPolygonPoints.length; i++){
            templgacodes.push(mapboxtempPolygonPoints[i].properties.lgacode)
        }
        //console.log(templgacodes);

        map.setFilter('polygon-highlighted', ['in', 'lgacode', ...templgacodes]);
    }

    function Allpointset() {

        group_select.selectAll("circle")
            .attr("cx", function(data) {
                //console.log(data);
                return project(data.coordinates).x;
            })
            .attr("cy", function(data) {
                return project(data.coordinates).y;
            })
        group_select.selectAll("circle")
            .on('click', function (params){
                if (d3.event.defaultPrevented) {
                    return;
                }
                console.log(params);
            })
        group_select.selectAll(".node")
            .attr("transform", function (data) {
                //console.log(data);
                return "translate(" + project(data.coordinates).x + "," + project(data.coordinates).y + ")";
            });

        d3.select('#group_nodecluster').selectAll(".node")
            .attr("transform", function (data) {
                //console.log(data);
                return "translate(" + project(data.coordinates).x + "," + project(data.coordinates).y + ")";
            });

        d3.select('#group_nodeuncluster').selectAll(".node")
            .attr("transform", function(data) {
                //console.log(data);
                return "translate(" + project(data.properties.geo_point_2d).x + "," + project(data.properties.geo_point_2d).y + ")";
            });

        d3.select('#group_nodeuncluster').selectAll("circle")
            .attr("cx", function(data) {
                return project(data.properties.geo_point_2d).x;
            })
            .attr("cy", function(data) {
                return project(data.properties.geo_point_2d).y;
            });

        console.log('All points set.');
    }

    function QueryIntialMap(tempnumber, tempsaveforeach, callback1 , callback2){
        console.log("Query map elements");

        var features_allcluster = map.queryRenderedFeatures({ layers: ['lga-center-clustered'] });
        var features_alluncluster = map.queryRenderedFeatures({ layers: ['lga-center-unclustered'] });
        //console.log(features_allcluster);
        var clusterarrintial = [];
        var j = 0;
        for (var i = 0; i < features_allcluster.length; i++) {

            //console.log(features_cluster[i]);
            var clusterId = features_allcluster[i].properties.cluster_id,
                point_count = features_allcluster[i].properties.point_count,
                clusterSource = map.getSource('lga-center-clustered');
            //console.log(clusterSource);
            // Get all points under a cluster

            var pt= clusterSource.getClusterLeaves(clusterId, point_count, 0, (err, aFeatures) =>{
                clusterarrintial.push(aFeatures);
                console.log('here')
                // console.log(clusterarr);
                //console.log(aFeatures);
                j ++;
                //console.log(j);
                if (features_allcluster.length === j ){
                    console.log('here2')
                    // console.log(clusterarr);
                    callback1(tempnumber, tempsaveforeach, clusterarrintial, features_alluncluster, callback2);
                    //setTimeout(callback1(clusterarrintial, features_alluncluster, callback2), 100)
                    //clearInterval(ss);
                    //return;
                }
                //console.log('getClusterLeaves', err, aFeatures);
                // clusterstring += JSON.stringify(
                //     aFeatures,
                //     null,
                //     2
                // );
            })
            //console.log(i);
            // console.log(pt)

        }


    }
    function QueryIntialMapCluster(tempnumber, tempsaveforeach, clusterarrintial, features_alluncluster, callback){

        // console.log(clusterarrintial);
        // console.log(features_alluncluster);
        // console.log(tempnumber);
        //unclustereddata
        for (let i = 0; i < features_alluncluster.length; i ++){
            let uppername = features_alluncluster[i].properties.name.toLowerCase();
            let uppernamefinal = uppername.charAt(0).toUpperCase() + uppername.slice(1); //
            tempsaveforeach.push({
                "Name": uppernamefinal,
                "LGAcode": features_alluncluster[i].properties.lgacode,
                "caseslist": JSON.parse(features_alluncluster[i].properties.caseslist),
                "status": "unclustered",
                "timespan": "2020-2022",
                "count": 1,
                "coordinates": features_alluncluster[i].geometry.coordinates
            });

        }

        //initialclustereddata
        var tempcentrepoint = [];
        for (let i = 0; i < clusterarrintial.length; i++){
            let temp_x = 0, temp_y=0;
            let count = 0;
            let centrepointstring = "";
            let centrepointlgastring = "";
            let centrepointcaseslist = new Array(tempnumber).fill(0);
            let tempcount = 0;
            //var centrepointalllgacode = [];

            for (let a = 0; a < clusterarrintial[i].length; a ++)
            {
                //console.log(otherclusterarr[i][a]);
                temp_x += Number(clusterarrintial[i][a].geometry.coordinates[0]);
                temp_y += Number(clusterarrintial[i][a].geometry.coordinates[1]);
                count ++;
                let uppername0 = clusterarrintial[i][a].properties.name.toLowerCase();//
                let uppernamefinal = uppername0.charAt(0).toUpperCase() + uppername0.slice(1); //
                centrepointstring +=  uppernamefinal + ", ";
                centrepointlgastring += clusterarrintial[i][a].properties.lgacode + "-";
                for (let k = 0; k < clusterarrintial[i][a].properties.caseslist.length; k++){
                    //if (clusterarrintial[i][a].properties.caseslist[k]["Month"] === k + 1){
                    centrepointcaseslist[k] += clusterarrintial[i][a].properties.caseslist[k]["cases"];
                    // }
                }
                //console.log(centrepointcaseslist);
                //centrepointalllgacode.push(selectedarr[a].lgacode);
            }

            let centre_coordinates = [temp_y / count, temp_x / count];
            //console.log(centre_coordinates);
            tempcentrepoint.push({
                "name": centrepointstring.substring(0, centrepointstring.length - 2),
                "lgacode": templgacodestore,
                "coordinates": centre_coordinates,
                "caseslist": centrepointcaseslist

            });
            // console.log(temp_x);
            // console.log(temp_y);
            //console.log(centrepoint);
            //console.log();
            let templgasum = [];
            for (let l = 0; l < centrepointcaseslist.length; l++){
                templgasum.push({
                    "Month": l + 1,
                    "cases": centrepointcaseslist[l],
                    "start": 360 / centrepointcaseslist.length * l,
                    "end": 360 / centrepointcaseslist.length * (l+1)
                });
            }

            tempsaveforeach.push({
                "Name": centrepointstring.substring(0, centrepointstring.length - 2),
                "LGAcode": centrepointlgastring.substring(0, centrepointlgastring.length - 1),
                "caseslist": templgasum,
                "status": "clustered",
                "timespan": "2020-2022",
                "count": clusterarrintial[i].length,
                "coordinates": centre_coordinates,
            });
        }



        callback(tempsaveforeach, tempsaveforeach);




    }
    function WriteIntialMap(tempsaveforeach, tempsaveforeach){
        var mapcenter = map.getCenter();
        var mapzoom = map.getZoom();
        var mapbearing = map.getBearing();
        var mappitch = map.getPitch();
        var mapcurrentSource = map.getSource('lga-center-clustered');
        savetotaldata.push({
            "Storageid": storeid,
            "mappara": [{
                "mapcenter": mapcenter,
                "mapzoom": mapzoom,
                "clusterradius": mapcurrentSource._options.clusterRadius,
                "mapbearing": mapbearing,
                "mappitch": mappitch
            }],
            "Details": tempsaveforeach,
            "Timeline": window.timeSelection
        })
        //
        window.totaldataforce = savetotaldata;

        if(window.dispatchEvent) {
            window.dispatchEvent(myEvent);
        } else {
            window.fireEvent(myEvent);
        }
        //matrix chart starts



        playRects(appendIdStr, window.totaldataforce, styleControler, cols + 1, rectPadding, mapcirclecolor);
        // var matrixdata = d3.json("./Data/testmatrix.json", function(error, values) {
        //     playRects(appendIdStr, values, styleControler, cols + 1, rectPadding, mapcirclecolor);
        // });
        //console.log(savetotaldata);
    }

    function QueryUpdateMap(tempnumber, tempsaveforeach, callback1 , callback2){
        console.log("Query map elements update");

        var features_allcluster = map.queryRenderedFeatures({ layers: ['lga-center-clustered'] });
        var features_alluncluster = map.queryRenderedFeatures({ layers: ['lga-center-unclustered'] });
        //console.log(features_allcluster);
        var clusterarrintial = [];
        var j = 0;
        for (var i = 0; i < features_allcluster.length; i++) {

            //console.log(features_cluster[i]);
            var clusterId = features_allcluster[i].properties.cluster_id,
                point_count = features_allcluster[i].properties.point_count,
                clusterSource = map.getSource('lga-center-clustered');
            //console.log(clusterSource);
            // Get all points under a cluster

            var pt= clusterSource.getClusterLeaves(clusterId, point_count, 0, (err, aFeatures) =>{
                clusterarrintial.push(aFeatures);
                console.log('here')
                // console.log(clusterarr);
                //console.log(aFeatures);
                j ++;
                //console.log(j);
                if (features_allcluster.length === j ){
                    console.log('here2')
                    // console.log(clusterarr);
                    callback1(tempnumber, tempsaveforeach, clusterarrintial, features_alluncluster, callback2);
                    //setTimeout(callback1(clusterarrintial, features_alluncluster, callback2), 100)
                    //clearInterval(ss);
                    //return;
                }
                //console.log('getClusterLeaves', err, aFeatures);
                // clusterstring += JSON.stringify(
                //     aFeatures,
                //     null,
                //     2
                // );
            })
            //console.log(i);
            // console.log(pt)

        }


    }
    function QueryUpdateMapCluster(tempnumber, tempsaveforeach, clusterarrintial, features_alluncluster, callback){

        // console.log(clusterarrintial);
        // console.log(features_alluncluster);
        // console.log(tempnumber);
        //unclustereddata
        for (let i = 0; i < features_alluncluster.length; i ++){
            let uppername = features_alluncluster[i].properties.name.toLowerCase();
            let uppernamefinal = uppername.charAt(0).toUpperCase() + uppername.slice(1); //11
            var tempcaseslist = JSON.parse(features_alluncluster[i].properties.caseslist);
            if (updatefeatures.length > 0){
                tempcaseslist =  tempcaseslist.slice(updatefeatures.timelinelist[0], updatefeatures.timelinelist[1]);
            }

            tempsaveforeach.push({
                "Name": uppernamefinal,
                "LGAcode": features_alluncluster[i].properties.lgacode,
                "caseslist": tempcaseslist,
                "status": "unclustered",
                "timespan": "2020-2022",
                "count": 1,
                "coordinates": features_alluncluster[i].geometry.coordinates
            });

        }

        //initialclustereddata
        var tempcentrepoint = [];
        for (let i = 0; i < clusterarrintial.length; i++){
            let temp_x = 0, temp_y=0;
            let count = 0;
            let centrepointstring = "";
            let centrepointlgastring = "";
            let centrepointcaseslist = new Array(tempnumber).fill(0);
            let tempcount = 0;
            //var centrepointalllgacode = [];

            for (let a = 0; a < clusterarrintial[i].length; a ++)
            {
                //console.log(otherclusterarr[i][a]);
                temp_x += Number(clusterarrintial[i][a].geometry.coordinates[0]);
                temp_y += Number(clusterarrintial[i][a].geometry.coordinates[1]);
                count ++;
                let uppername0 = clusterarrintial[i][a].properties.name.toLowerCase();//
                let uppernamefinal = uppername0.charAt(0).toUpperCase() + uppername0.slice(1); //
                centrepointstring +=  uppernamefinal + ", ";
                centrepointlgastring += clusterarrintial[i][a].properties.lgacode + "-";
                for (let k = 0; k < clusterarrintial[i][a].properties.caseslist.length; k++){
                    //if (clusterarrintial[i][a].properties.caseslist[k]["Month"] === k + 1){
                    centrepointcaseslist[k] += clusterarrintial[i][a].properties.caseslist[k]["cases"];
                    // }
                }
                //console.log(centrepointcaseslist);
                //centrepointalllgacode.push(selectedarr[a].lgacode);
            }

            let centre_coordinates = [temp_y / count, temp_x / count];
            //console.log(centre_coordinates);
            tempcentrepoint.push({
                "name": centrepointstring.substring(0, centrepointstring.length - 2),
                "lgacode": templgacodestore,
                "coordinates": centre_coordinates,
                "caseslist": centrepointcaseslist

            });
            // console.log(temp_x);
            // console.log(temp_y);
            //console.log(centrepoint);
            //console.log();
            let templgasum = [];
            for (let l = 0; l < centrepointcaseslist.length; l++){
                templgasum.push({
                    "Month": l + 1,
                    "cases": centrepointcaseslist[l],
                    "start": 360 / centrepointcaseslist.length * l,
                    "end": 360 / centrepointcaseslist.length * (l+1)
                });
            }

            tempsaveforeach.push({
                "Name": centrepointstring.substring(0, centrepointstring.length - 2),
                "LGAcode": centrepointlgastring.substring(0, centrepointlgastring.length - 1),
                "caseslist": templgasum,
                "status": "clustered",
                "timespan": "2020-2022",
                "count": clusterarrintial[i].length,
                "coordinates": centre_coordinates,
            });
        }

        //console.log(tempsaveforeach);

        callback(tempsaveforeach);

    }
    function WriteUpdateMap(tempsaveforeach){
        var mapcenter = map.getCenter();
        var mapzoom = map.getZoom();
        var mapbearing = map.getBearing();
        var mappitch = map.getPitch();
        var mapcurrentSource = map.getSource('lga-center-clustered');
        tempsaveforeach = UniqueDetailsLGA(tempsaveforeach);
        savetotaldata.push({
            "Storageid": storeid,
            "mappara": [{
                "mapcenter": mapcenter,
                "mapzoom": mapzoom,
                "clusterradius": mapcurrentSource._options.clusterRadius,
                "mapbearing": mapbearing,
                "mappitch": mappitch
            }],
            "Details": tempsaveforeach,
            "Timeline": window.timeSelection
        })
        //
        window.totaldataforce = UniqueStoreageid(savetotaldata);
        // //console.log(window.totaldataforce );
        if(window.dispatchEvent) {
            window.dispatchEvent(myEvent);
        } else {
            window.fireEvent(myEvent);
        }
        //matrix chart starts



        playRects(appendIdStr, window.totaldataforce, styleControler, cols + 1, rectPadding, mapcirclecolor);
        // var matrixdata = d3.json("./Data/testmatrix.json", function(error, values) {
        //     playRects(appendIdStr, values, styleControler, cols + 1, rectPadding, mapcirclecolor);
        // });
        //console.log(savetotaldata);
    }

    function Findgroupdata(tempsaveforeach, callback1, callback2){
        console.log('Findgroupdata');
        console.log(tempLGAcenterofMonth.features); //all unclustered points
        console.log(unclusterdiff); //all unclustered points？
        console.log(tempclustersinfo); // all cluster details
        console.log(otherclusterarr); // all cluster details？
        console.log(tempfinalcenterpointcopy); // all grouped details，respone after clicking button
        console.log(finalcenterpointallcaseslist); // all grouped details，respone after clicking button//
        var tempclustertest = [];
        var tempunclustertest = [];

        //判断
        for (var i = 0; i < otherclusterarr.length; i++){
            var tempclusterstr = "";
            for (var j = 0; j < otherclusterarr[i].length; j++){
                tempclusterstr += otherclusterarr[i][j].properties.lgacode + "-";
            }
            tempclusterstr = tempclusterstr.substring(0, tempclusterstr.lastIndexOf('-'));
            tempclustertest.push(tempclusterstr)
        }
        //console.log(tempclustertest);
        var tempmarknumber = []
        for (var a = 0; a < tempclustertest.length; a++){
            for (var b = 0; b < finalcenterpoint.length; b++){
                if (finalcenterpoint[b].clusterlgacode.indexOf(tempclustertest[a]) != -1){
                    tempmarknumber.push(a);
                }
            }
        }

        //console.log(unclusterdiff);

        for (var c = 0; c < unclusterdiff.length; c++){
            tempunclustertest.push(unclusterdiff[c].properties.lgacode);
        }
        var tempmarknumber2 = []
        for (var a = 0; a < tempunclustertest.length; a++){
            for (var b = 0; b < finalcenterpoint.length; b++){
                if (finalcenterpoint[b].clusterlgacode.indexOf(tempunclustertest[a]) != -1){
                    tempmarknumber2.push(a);
                }
            }
        }

        callback1(tempmarknumber, tempmarknumber2, tempsaveforeach, callback2);
    }
    function Findgroupdata1(tempmarknumber, tempmarknumber2, tempsaveforeach, callback1){
        console.log('Findgroupdata1');
        console.log(tempmarknumber);
        console.log(tempmarknumber2);

        tempmarknumber = tempmarknumber.reverse();
        tempmarknumber2 = tempmarknumber2.reverse();

        for (var a = 0; a < tempmarknumber.length; a++){
            otherclusterarr.splice(tempmarknumber[a], 1);
        }
        for (var b = 0; b < tempmarknumber2.length; b++){
            unclusterdiff.splice(tempmarknumber2[b], 1);
        }



        //console.log(savetotaldata)
        //window.totaldataforce = UniqueStoreageid(window.totaldataforce)
        //保存更新方块图


        callback1(tempsaveforeach);
    }
    function Findgroupdata2(tempsaveforeach){
        console.log('Findgroupdata2');

        var tempsaveforgroup = [];
        //console.log(tempnumber);

        console.log(finalcenterpoint); //第二次的group caseslist不全
        console.log(otherclusterarr); //所有caseslist不全，是第一次的时间
        //console.log(otherclusterarrrevised);
        console.log(unclusterdiff); //所有caseslist不全，是第一次的时间

        console.log(tempLGAcenterofMonth.features); //all unclustered points
        console.log(unclusterdiff); //all unclustered points？
        console.log(tempclustersinfo); // all cluster details
        console.log(otherclusterarr); // all cluster details？
        console.log(tempfinalcenterpointcopy); // all grouped details，respone after clicking button

        console.log(temptimearr[0], temptimearr[1]); //当前截取参数是多少
        //groupeddata
        for (let x = 0; x < finalcenterpointallcaseslist.length; x++) {
            var centerpointtempcopy = JSON.stringify(finalcenterpointallcaseslist[x].caseslist);
            //var centerpointtempcaseslist = JSON.parse(centerpointtempcopy);
            var centerpointtempcaseslist = JSON.parse(centerpointtempcopy).slice(temptimearr[0], temptimearr[1]); //1
            let tempsave1 = {

                "Name": finalcenterpointallcaseslist[x].clustername.charAt(0).toUpperCase() + finalcenterpointallcaseslist[x].clustername.slice(1), //
                "LGAcode": finalcenterpointallcaseslist[x].clusterlgacode,
                "caseslist": centerpointtempcaseslist,
                "status": "grouped",
                "timespan": "2020-2022",
                "count": finalcenterpointallcaseslist[x].count,
                "coordinates": finalcenterpointallcaseslist[x].coordinates
            };
            tempsaveforgroup.push(tempsave1)
        }

        //console.log(tempsaveforgroup);

        for (var i = 0; i < tempsaveforgroup.length; i++){
            for (var j = 0; j < tempsaveforgroup[i].caseslist.length; j ++){
                tempsaveforgroup[i].caseslist[j]["start"] = 360 / tempsaveforgroup[i].caseslist.length * j;
                tempsaveforgroup[i].caseslist[j]["end"] = 360 / tempsaveforgroup[i].caseslist.length * (j + 1);
            }
            tempsaveforeach.push(tempsaveforgroup[i]);
        }

        //copy otherclusterarr


        //console.log(otherclusterarr);
        if (otherclusterarr.length > 0) {
            //otherclustereddata
            var otherclusterarrtostring = JSON.stringify(otherclusterarr);
            var otherclusterarrcopy = JSON.parse(otherclusterarrtostring);

            var tempcentrepoint = [];
            for (let i = 0; i < otherclusterarrcopy.length; i++) {
                let temp_x = 0, temp_y = 0;
                let count = 0;
                let centrepointstring = "";
                let centrepointlgastring = "";
                let tempcentrepointcaseslist = new Array(25).fill(0);
                //var centrepointalllgacode = [];
                // var MonthCount = Number(window.realtimetimestart);
                // console.log(MonthCount);
                for (let a = 0; a < otherclusterarrcopy[i].length; a++) {
                    //console.log(otherclusterarr[i][a]);
                    temp_x += Number(otherclusterarrcopy[i][a].geometry.coordinates[0]);
                    temp_y += Number(otherclusterarrcopy[i][a].geometry.coordinates[1]);
                    count++;


                    let uppername0 = otherclusterarrcopy[i][a].properties.name.toLowerCase();
                    let uppernamefinal = uppername0.charAt(0).toUpperCase() + uppername0.slice(1); //
                    centrepointstring += uppernamefinal + ", ";
                    centrepointlgastring += otherclusterarrcopy[i][a].properties.lgacode + "-";
                    for (let k = 0; k < otherclusterarrcopy[i][a].properties.caseslist.length; k++) {
                        //if (otherclusterarr[i][a].properties.caseslist[k]["Month"] === MonthCount + 1) {
                        tempcentrepointcaseslist[k] += otherclusterarrcopy[i][a].properties.caseslist[k]["cases"];
                        //MonthCount ++;
                        //}

                    }
                    //centrepointalllgacode.push(selectedarr[a].lgacode);
                }

                let centre_coordinates = [temp_y / count, temp_x / count];

                tempcentrepointcaseslist = tempcentrepointcaseslist.slice(temptimearr[0], temptimearr[1]);
                console.log(tempcentrepointcaseslist);
                // tempcentrepointcaseslist = tempcentrepointcaseslist.delNaN();
                var centretempname = centrepointstring.substring(0, centrepointstring.length - 2)
                tempcentrepoint.push({
                    "name": centretempname.charAt(0).toUpperCase() + centretempname.slice(1), //
                    "lgacode": templgacodestore,
                    "coordinates": centre_coordinates,
                    "caseslist": tempcentrepointcaseslist

                });
                // console.log(temp_x);
                // console.log(temp_y);
                //console.log(centrepointcaseslist);
                //console.log();
                let templgasum = [];
                for (let l = 0; l < tempcentrepointcaseslist.length; l++) {
                    templgasum.push({
                        "Month": l + temptimearr[0] + 1,
                        "cases": tempcentrepointcaseslist[l],
                        "start": 360 / tempcentrepointcaseslist.length * l,
                        "end": 360 / tempcentrepointcaseslist.length * (l + 1)
                    });
                }

                var tempclustername = centrepointstring.substring(0, centrepointstring.length - 2)

                tempsaveforeach.push({
                    "Name": tempclustername.charAt(0).toUpperCase() + tempclustername.slice(1),
                    "LGAcode": centrepointlgastring.substring(0, centrepointlgastring.length - 1),
                    "caseslist": templgasum,
                    "status": "clustered",
                    "timespan": "2020-2022",
                    "count": otherclusterarrcopy[i].length,
                    "coordinates": centre_coordinates,
                });
            }
        }

        //unclustereddata
        var tempsaveforuncluster = [];
        for (var i = 0; i < unclusterdiff.length; i ++){
            var uppername = unclusterdiff[i].properties.name.toLowerCase();
            var unclusterdiffcopy = JSON.parse(unclusterdiff[i].properties.caseslist)
            var unclusterdiffcopytocaseslist = unclusterdiffcopy.slice(temptimearr[0], temptimearr[1]);
            tempsaveforuncluster.push({
                "Name": uppername.charAt(0).toUpperCase() + uppername.slice(1),
                "LGAcode": unclusterdiff[i].properties.lgacode,
                "caseslist": unclusterdiffcopytocaseslist,
                "status": "unclustered",
                "timespan": "2020-2022",
                "count": 1,
                "coordinates": unclusterdiff[i].geometry.coordinates
            });
        }
        for (var a = 0; a < tempsaveforuncluster.length; a++){
            for (var b=0; b<tempsaveforuncluster[a].caseslist.length; b++){
                tempsaveforuncluster[a].caseslist[b]["start"] = 360 / tempsaveforuncluster[a].caseslist.length * b;
                tempsaveforuncluster[a].caseslist[b]["end"] = 360 / tempsaveforuncluster[a].caseslist.length * (b + 1);
            }
            tempsaveforeach.push(tempsaveforuncluster[a]);

        }


        tempsaveforeach = UniqueDetailsLGA(tempsaveforeach);
        var mapcenter = map.getCenter();
        var mapzoom = map.getZoom();
        var mapbearing = map.getBearing();
        var mappitch = map.getPitch();
        var mapcurrentSource = map.getSource('lga-center-clustered');
        if (tempsaveforeach.length >0){

            savetotaldata.push({
                "Storageid": storeid,
                "mappara": [{
                    "mapcenter": mapcenter,
                    "mapzoom": mapzoom,
                    "clusterradius": mapcurrentSource._options.clusterRadius,
                    "mapbearing": mapbearing,
                    "mappitch": mappitch
                }],
                "Details": tempsaveforeach,
                "Timeline": window.timeSelection
            })
        }

        window.totaldataforce = savetotaldata;
        console.log(window.totaldataforce);

        if(window.dispatchEvent) {
            window.dispatchEvent(myEvent);
        } else {
            window.fireEvent(myEvent);
        }
        playRects(appendIdStr, window.totaldataforce, styleControler, cols + 1, rectPadding, mapcirclecolor);

    }

    Array.prototype.delNaN=function(){
        var arr=[];
        for(var i=0;i<this.length;i++){
            if(this[i]===this[i]){
                arr.push(this[i]);
            }
        }
        return arr;
    }

</script>
</body>